// Autogenerated from Pigeon (v9.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name, unnecessary_import

import 'dart:async';
import 'dart:typed_data' show Float64List, Int32List, Int64List, Uint8List;

import 'package:flutter/foundation.dart' show ReadBuffer, WriteBuffer;
import 'package:flutter/services.dart';

/// Pigeon only supports classes as return/receive type.
/// That is why we must wrap primitive types into wrapper
class BooleanWrapper {
  BooleanWrapper({
    this.value,
  });

  bool? value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static BooleanWrapper decode(Object result) {
    result as List<Object?>;
    return BooleanWrapper(
      value: result[0] as bool?,
    );
  }
}

class NumberWrapper {
  NumberWrapper({
    this.value,
  });

  int? value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static NumberWrapper decode(Object result) {
    result as List<Object?>;
    return NumberWrapper(
      value: result[0] as int?,
    );
  }
}

class StringWrapper {
  StringWrapper({
    this.value,
  });

  String? value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static StringWrapper decode(Object result) {
    result as List<Object?>;
    return StringWrapper(
      value: result[0] as String?,
    );
  }
}

class ListWrapper {
  ListWrapper({
    this.value,
  });

  List<Object?>? value;

  Object encode() {
    return <Object?>[
      value,
    ];
  }

  static ListWrapper decode(Object result) {
    result as List<Object?>;
    return ListWrapper(
      value: result[0] as List<Object?>?,
    );
  }
}

class PebbleFirmwarePigeon {
  PebbleFirmwarePigeon({
    this.timestamp,
    this.version,
    this.gitHash,
    this.isRecovery,
    this.hardwarePlatform,
    this.metadataVersion,
  });

  int? timestamp;

  String? version;

  String? gitHash;

  bool? isRecovery;

  int? hardwarePlatform;

  int? metadataVersion;

  Object encode() {
    return <Object?>[
      timestamp,
      version,
      gitHash,
      isRecovery,
      hardwarePlatform,
      metadataVersion,
    ];
  }

  static PebbleFirmwarePigeon decode(Object result) {
    result as List<Object?>;
    return PebbleFirmwarePigeon(
      timestamp: result[0] as int?,
      version: result[1] as String?,
      gitHash: result[2] as String?,
      isRecovery: result[3] as bool?,
      hardwarePlatform: result[4] as int?,
      metadataVersion: result[5] as int?,
    );
  }
}

class PebbleDevicePigeon {
  PebbleDevicePigeon({
    this.name,
    this.address,
    this.runningFirmware,
    this.recoveryFirmware,
    this.model,
    this.bootloaderTimestamp,
    this.board,
    this.serial,
    this.language,
    this.languageVersion,
    this.isUnfaithful,
  });

  String? name;

  String? address;

  PebbleFirmwarePigeon? runningFirmware;

  PebbleFirmwarePigeon? recoveryFirmware;

  int? model;

  int? bootloaderTimestamp;

  String? board;

  String? serial;

  String? language;

  int? languageVersion;

  bool? isUnfaithful;

  Object encode() {
    return <Object?>[
      name,
      address,
      runningFirmware?.encode(),
      recoveryFirmware?.encode(),
      model,
      bootloaderTimestamp,
      board,
      serial,
      language,
      languageVersion,
      isUnfaithful,
    ];
  }

  static PebbleDevicePigeon decode(Object result) {
    result as List<Object?>;
    return PebbleDevicePigeon(
      name: result[0] as String?,
      address: result[1] as String?,
      runningFirmware: result[2] != null
          ? PebbleFirmwarePigeon.decode(result[2]! as List<Object?>)
          : null,
      recoveryFirmware: result[3] != null
          ? PebbleFirmwarePigeon.decode(result[3]! as List<Object?>)
          : null,
      model: result[4] as int?,
      bootloaderTimestamp: result[5] as int?,
      board: result[6] as String?,
      serial: result[7] as String?,
      language: result[8] as String?,
      languageVersion: result[9] as int?,
      isUnfaithful: result[10] as bool?,
    );
  }
}

class PebbleScanDevicePigeon {
  PebbleScanDevicePigeon({
    this.name,
    this.address,
    this.version,
    this.serialNumber,
    this.color,
    this.runningPRF,
    this.firstUse,
  });

  String? name;

  String? address;

  String? version;

  String? serialNumber;

  int? color;

  bool? runningPRF;

  bool? firstUse;

  Object encode() {
    return <Object?>[
      name,
      address,
      version,
      serialNumber,
      color,
      runningPRF,
      firstUse,
    ];
  }

  static PebbleScanDevicePigeon decode(Object result) {
    result as List<Object?>;
    return PebbleScanDevicePigeon(
      name: result[0] as String?,
      address: result[1] as String?,
      version: result[2] as String?,
      serialNumber: result[3] as String?,
      color: result[4] as int?,
      runningPRF: result[5] as bool?,
      firstUse: result[6] as bool?,
    );
  }
}

class WatchConnectionStatePigeon {
  WatchConnectionStatePigeon({
    required this.isConnected,
    required this.isConnecting,
    this.currentWatchAddress,
    this.currentConnectedWatch,
  });

  bool isConnected;

  bool isConnecting;

  String? currentWatchAddress;

  PebbleDevicePigeon? currentConnectedWatch;

  Object encode() {
    return <Object?>[
      isConnected,
      isConnecting,
      currentWatchAddress,
      currentConnectedWatch?.encode(),
    ];
  }

  static WatchConnectionStatePigeon decode(Object result) {
    result as List<Object?>;
    return WatchConnectionStatePigeon(
      isConnected: result[0]! as bool,
      isConnecting: result[1]! as bool,
      currentWatchAddress: result[2] as String?,
      currentConnectedWatch: result[3] != null
          ? PebbleDevicePigeon.decode(result[3]! as List<Object?>)
          : null,
    );
  }
}

class TimelinePinPigeon {
  TimelinePinPigeon({
    this.itemId,
    this.parentId,
    this.timestamp,
    this.type,
    this.duration,
    this.isVisible,
    this.isFloating,
    this.isAllDay,
    this.persistQuickView,
    this.layout,
    this.attributesJson,
    this.actionsJson,
  });

  String? itemId;

  String? parentId;

  int? timestamp;

  int? type;

  int? duration;

  bool? isVisible;

  bool? isFloating;

  bool? isAllDay;

  bool? persistQuickView;

  int? layout;

  String? attributesJson;

  String? actionsJson;

  Object encode() {
    return <Object?>[
      itemId,
      parentId,
      timestamp,
      type,
      duration,
      isVisible,
      isFloating,
      isAllDay,
      persistQuickView,
      layout,
      attributesJson,
      actionsJson,
    ];
  }

  static TimelinePinPigeon decode(Object result) {
    result as List<Object?>;
    return TimelinePinPigeon(
      itemId: result[0] as String?,
      parentId: result[1] as String?,
      timestamp: result[2] as int?,
      type: result[3] as int?,
      duration: result[4] as int?,
      isVisible: result[5] as bool?,
      isFloating: result[6] as bool?,
      isAllDay: result[7] as bool?,
      persistQuickView: result[8] as bool?,
      layout: result[9] as int?,
      attributesJson: result[10] as String?,
      actionsJson: result[11] as String?,
    );
  }
}

class NotifActionExecuteReq {
  NotifActionExecuteReq({
    this.itemId,
    this.actionId,
    this.responseText,
  });

  String? itemId;

  int? actionId;

  String? responseText;

  Object encode() {
    return <Object?>[
      itemId,
      actionId,
      responseText,
    ];
  }

  static NotifActionExecuteReq decode(Object result) {
    result as List<Object?>;
    return NotifActionExecuteReq(
      itemId: result[0] as String?,
      actionId: result[1] as int?,
      responseText: result[2] as String?,
    );
  }
}

class AppEntriesPigeon {
  AppEntriesPigeon({
    this.appName,
    this.packageId,
  });

  List<String?>? appName;

  List<String?>? packageId;

  Object encode() {
    return <Object?>[
      appName,
      packageId,
    ];
  }

  static AppEntriesPigeon decode(Object result) {
    result as List<Object?>;
    return AppEntriesPigeon(
      appName: (result[0] as List<Object?>?)?.cast<String?>(),
      packageId: (result[1] as List<Object?>?)?.cast<String?>(),
    );
  }
}

class PbwAppInfo {
  PbwAppInfo({
    this.isValid,
    this.uuid,
    this.shortName,
    this.longName,
    this.companyName,
    this.versionCode,
    this.versionLabel,
    this.appKeys,
    this.capabilities,
    this.resources,
    this.sdkVersion,
    this.targetPlatforms,
    this.watchapp,
  });

  bool? isValid;

  String? uuid;

  String? shortName;

  String? longName;

  String? companyName;

  int? versionCode;

  String? versionLabel;

  Map<String?, int?>? appKeys;

  List<String?>? capabilities;

  List<WatchResource?>? resources;

  String? sdkVersion;

  List<String?>? targetPlatforms;

  WatchappInfo? watchapp;

  Object encode() {
    return <Object?>[
      isValid,
      uuid,
      shortName,
      longName,
      companyName,
      versionCode,
      versionLabel,
      appKeys,
      capabilities,
      resources,
      sdkVersion,
      targetPlatforms,
      watchapp?.encode(),
    ];
  }

  static PbwAppInfo decode(Object result) {
    result as List<Object?>;
    return PbwAppInfo(
      isValid: result[0] as bool?,
      uuid: result[1] as String?,
      shortName: result[2] as String?,
      longName: result[3] as String?,
      companyName: result[4] as String?,
      versionCode: result[5] as int?,
      versionLabel: result[6] as String?,
      appKeys: (result[7] as Map<Object?, Object?>?)?.cast<String?, int?>(),
      capabilities: (result[8] as List<Object?>?)?.cast<String?>(),
      resources: (result[9] as List<Object?>?)?.cast<WatchResource?>(),
      sdkVersion: result[10] as String?,
      targetPlatforms: (result[11] as List<Object?>?)?.cast<String?>(),
      watchapp: result[12] != null
          ? WatchappInfo.decode(result[12]! as List<Object?>)
          : null,
    );
  }
}

class WatchappInfo {
  WatchappInfo({
    this.watchface,
    this.hiddenApp,
    this.onlyShownOnCommunication,
  });

  bool? watchface;

  bool? hiddenApp;

  bool? onlyShownOnCommunication;

  Object encode() {
    return <Object?>[
      watchface,
      hiddenApp,
      onlyShownOnCommunication,
    ];
  }

  static WatchappInfo decode(Object result) {
    result as List<Object?>;
    return WatchappInfo(
      watchface: result[0] as bool?,
      hiddenApp: result[1] as bool?,
      onlyShownOnCommunication: result[2] as bool?,
    );
  }
}

class WatchResource {
  WatchResource({
    this.file,
    this.menuIcon,
    this.name,
    this.type,
  });

  String? file;

  bool? menuIcon;

  String? name;

  String? type;

  Object encode() {
    return <Object?>[
      file,
      menuIcon,
      name,
      type,
    ];
  }

  static WatchResource decode(Object result) {
    result as List<Object?>;
    return WatchResource(
      file: result[0] as String?,
      menuIcon: result[1] as bool?,
      name: result[2] as String?,
      type: result[3] as String?,
    );
  }
}

class AppInstallStatus {
  AppInstallStatus({
    required this.progress,
    required this.isInstalling,
  });

  /// Progress in range [0-1]
  double progress;

  bool isInstalling;

  Object encode() {
    return <Object?>[
      progress,
      isInstalling,
    ];
  }

  static AppInstallStatus decode(Object result) {
    result as List<Object?>;
    return AppInstallStatus(
      progress: result[0]! as double,
      isInstalling: result[1]! as bool,
    );
  }
}

class ScreenshotResult {
  ScreenshotResult({
    required this.success,
    this.imagePath,
  });

  bool success;

  String? imagePath;

  Object encode() {
    return <Object?>[
      success,
      imagePath,
    ];
  }

  static ScreenshotResult decode(Object result) {
    result as List<Object?>;
    return ScreenshotResult(
      success: result[0]! as bool,
      imagePath: result[1] as String?,
    );
  }
}

class AppLogEntry {
  AppLogEntry({
    required this.uuid,
    required this.timestamp,
    required this.level,
    required this.lineNumber,
    required this.filename,
    required this.message,
  });

  String uuid;

  int timestamp;

  int level;

  int lineNumber;

  String filename;

  String message;

  Object encode() {
    return <Object?>[
      uuid,
      timestamp,
      level,
      lineNumber,
      filename,
      message,
    ];
  }

  static AppLogEntry decode(Object result) {
    result as List<Object?>;
    return AppLogEntry(
      uuid: result[0]! as String,
      timestamp: result[1]! as int,
      level: result[2]! as int,
      lineNumber: result[3]! as int,
      filename: result[4]! as String,
      message: result[5]! as String,
    );
  }
}

class OAuthResult {
  OAuthResult({
    this.code,
    this.state,
    this.error,
  });

  String? code;

  String? state;

  String? error;

  Object encode() {
    return <Object?>[
      code,
      state,
      error,
    ];
  }

  static OAuthResult decode(Object result) {
    result as List<Object?>;
    return OAuthResult(
      code: result[0] as String?,
      state: result[1] as String?,
      error: result[2] as String?,
    );
  }
}

class NotifyingPackage {
  NotifyingPackage({
    required this.packageId,
    required this.packageName,
  });

  String packageId;

  String packageName;

  Object encode() {
    return <Object?>[
      packageId,
      packageName,
    ];
  }

  static NotifyingPackage decode(Object result) {
    result as List<Object?>;
    return NotifyingPackage(
      packageId: result[0]! as String,
      packageName: result[1]! as String,
    );
  }
}

class CalendarPigeon {
  CalendarPigeon({
    required this.id,
    required this.account,
    required this.name,
    required this.color,
    required this.enabled,
  });

  int id;

  String account;

  String name;

  int color;

  bool enabled;

  Object encode() {
    return <Object?>[
      id,
      account,
      name,
      color,
      enabled,
    ];
  }

  static CalendarPigeon decode(Object result) {
    result as List<Object?>;
    return CalendarPigeon(
      id: result[0]! as int,
      account: result[1]! as String,
      name: result[2]! as String,
      color: result[3]! as int,
      enabled: result[4]! as bool,
    );
  }
}

class _CalendarCallbacksCodec extends StandardMessageCodec {
  const _CalendarCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CalendarPigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return CalendarPigeon.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class CalendarCallbacks {
  static const MessageCodec<Object?> codec = _CalendarCallbacksCodec();

  void onCalendarListUpdated(List<CalendarPigeon?> calendars);

  static void setup(CalendarCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.CalendarCallbacks.onCalendarListUpdated', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.CalendarCallbacks.onCalendarListUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final List<CalendarPigeon?>? arg_calendars = (args[0] as List<Object?>?)?.cast<CalendarPigeon?>();
          assert(arg_calendars != null,
              'Argument for dev.flutter.pigeon.CalendarCallbacks.onCalendarListUpdated was null, expected non-null List<CalendarPigeon?>.');
          api.onCalendarListUpdated(arg_calendars!);
          return;
        });
      }
    }
  }
}

class _ScanCallbacksCodec extends StandardMessageCodec {
  const _ScanCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PebbleScanDevicePigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return PebbleScanDevicePigeon.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class ScanCallbacks {
  static const MessageCodec<Object?> codec = _ScanCallbacksCodec();

  /// pebbles = list of PebbleScanDevicePigeon
  void onScanUpdate(List<PebbleScanDevicePigeon?> pebbles);

  void onScanStarted();

  void onScanStopped();

  static void setup(ScanCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ScanCallbacks.onScanUpdate', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.ScanCallbacks.onScanUpdate was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final List<PebbleScanDevicePigeon?>? arg_pebbles = (args[0] as List<Object?>?)?.cast<PebbleScanDevicePigeon?>();
          assert(arg_pebbles != null,
              'Argument for dev.flutter.pigeon.ScanCallbacks.onScanUpdate was null, expected non-null List<PebbleScanDevicePigeon?>.');
          api.onScanUpdate(arg_pebbles!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ScanCallbacks.onScanStarted', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onScanStarted();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ScanCallbacks.onScanStopped', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onScanStopped();
          return;
        });
      }
    }
  }
}

class _ConnectionCallbacksCodec extends StandardMessageCodec {
  const _ConnectionCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PebbleDevicePigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is PebbleFirmwarePigeon) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is WatchConnectionStatePigeon) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return PebbleDevicePigeon.decode(readValue(buffer)!);
      case 129: 
        return PebbleFirmwarePigeon.decode(readValue(buffer)!);
      case 130: 
        return WatchConnectionStatePigeon.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class ConnectionCallbacks {
  static const MessageCodec<Object?> codec = _ConnectionCallbacksCodec();

  void onWatchConnectionStateChanged(WatchConnectionStatePigeon newState);

  static void setup(ConnectionCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final WatchConnectionStatePigeon? arg_newState = (args[0] as WatchConnectionStatePigeon?);
          assert(arg_newState != null,
              'Argument for dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged was null, expected non-null WatchConnectionStatePigeon.');
          api.onWatchConnectionStateChanged(arg_newState!);
          return;
        });
      }
    }
  }
}

class _RawIncomingPacketsCallbacksCodec extends StandardMessageCodec {
  const _RawIncomingPacketsCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ListWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return ListWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class RawIncomingPacketsCallbacks {
  static const MessageCodec<Object?> codec = _RawIncomingPacketsCallbacksCodec();

  void onPacketReceived(ListWrapper listOfBytes);

  static void setup(RawIncomingPacketsCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final ListWrapper? arg_listOfBytes = (args[0] as ListWrapper?);
          assert(arg_listOfBytes != null,
              'Argument for dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived was null, expected non-null ListWrapper.');
          api.onPacketReceived(arg_listOfBytes!);
          return;
        });
      }
    }
  }
}

class _PairCallbacksCodec extends StandardMessageCodec {
  const _PairCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class PairCallbacks {
  static const MessageCodec<Object?> codec = _PairCallbacksCodec();

  void onWatchPairComplete(StringWrapper address);

  static void setup(PairCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.PairCallbacks.onWatchPairComplete', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.PairCallbacks.onWatchPairComplete was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final StringWrapper? arg_address = (args[0] as StringWrapper?);
          assert(arg_address != null,
              'Argument for dev.flutter.pigeon.PairCallbacks.onWatchPairComplete was null, expected non-null StringWrapper.');
          api.onWatchPairComplete(arg_address!);
          return;
        });
      }
    }
  }
}

class _IntentCallbacksCodec extends StandardMessageCodec {
  const _IntentCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class IntentCallbacks {
  static const MessageCodec<Object?> codec = _IntentCallbacksCodec();

  void openUri(StringWrapper uri);

  static void setup(IntentCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.IntentCallbacks.openUri', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.IntentCallbacks.openUri was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final StringWrapper? arg_uri = (args[0] as StringWrapper?);
          assert(arg_uri != null,
              'Argument for dev.flutter.pigeon.IntentCallbacks.openUri was null, expected non-null StringWrapper.');
          api.openUri(arg_uri!);
          return;
        });
      }
    }
  }
}

class _AppInstallStatusCallbacksCodec extends StandardMessageCodec {
  const _AppInstallStatusCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AppInstallStatus) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return AppInstallStatus.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class AppInstallStatusCallbacks {
  static const MessageCodec<Object?> codec = _AppInstallStatusCallbacksCodec();

  void onStatusUpdated(AppInstallStatus status);

  static void setup(AppInstallStatusCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final AppInstallStatus? arg_status = (args[0] as AppInstallStatus?);
          assert(arg_status != null,
              'Argument for dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated was null, expected non-null AppInstallStatus.');
          api.onStatusUpdated(arg_status!);
          return;
        });
      }
    }
  }
}

class _AppLogCallbacksCodec extends StandardMessageCodec {
  const _AppLogCallbacksCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AppLogEntry) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return AppLogEntry.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

abstract class AppLogCallbacks {
  static const MessageCodec<Object?> codec = _AppLogCallbacksCodec();

  void onLogReceived(AppLogEntry entry);

  static void setup(AppLogCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.AppLogCallbacks.onLogReceived', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.AppLogCallbacks.onLogReceived was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final AppLogEntry? arg_entry = (args[0] as AppLogEntry?);
          assert(arg_entry != null,
              'Argument for dev.flutter.pigeon.AppLogCallbacks.onLogReceived was null, expected non-null AppLogEntry.');
          api.onLogReceived(arg_entry!);
          return;
        });
      }
    }
  }
}

abstract class FirmwareUpdateCallbacks {
  static const MessageCodec<Object?> codec = StandardMessageCodec();

  void onFirmwareUpdateStarted();

  void onFirmwareUpdateProgress(double progress);

  void onFirmwareUpdateFinished();

  static void setup(FirmwareUpdateCallbacks? api, {BinaryMessenger? binaryMessenger}) {
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateStarted', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onFirmwareUpdateStarted();
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateProgress', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          assert(message != null,
          'Argument for dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateProgress was null.');
          final List<Object?> args = (message as List<Object?>?)!;
          final double? arg_progress = (args[0] as double?);
          assert(arg_progress != null,
              'Argument for dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateProgress was null, expected non-null double.');
          api.onFirmwareUpdateProgress(arg_progress!);
          return;
        });
      }
    }
    {
      final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
          'dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateFinished', codec,
          binaryMessenger: binaryMessenger);
      if (api == null) {
        channel.setMessageHandler(null);
      } else {
        channel.setMessageHandler((Object? message) async {
          // ignore message
          api.onFirmwareUpdateFinished();
          return;
        });
      }
    }
  }
}

class _NotificationUtilsCodec extends StandardMessageCodec {
  const _NotificationUtilsCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is NotifActionExecuteReq) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is StringWrapper) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return BooleanWrapper.decode(readValue(buffer)!);
      case 129: 
        return NotifActionExecuteReq.decode(readValue(buffer)!);
      case 130: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class NotificationUtils {
  /// Constructor for [NotificationUtils].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NotificationUtils({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _NotificationUtilsCodec();

  Future<BooleanWrapper> dismissNotification(StringWrapper arg_itemId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.dismissNotification', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_itemId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }

  Future<void> dismissNotificationWatch(StringWrapper arg_itemId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.dismissNotificationWatch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_itemId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> openNotification(StringWrapper arg_itemId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.openNotification', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_itemId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> executeAction(NotifActionExecuteReq arg_action) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationUtils.executeAction', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_action]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class ScanControl {
  /// Constructor for [ScanControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ScanControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> startBleScan() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ScanControl.startBleScan', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> startClassicScan() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ScanControl.startClassicScan', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _ConnectionControlCodec extends StandardMessageCodec {
  const _ConnectionControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is ListWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return BooleanWrapper.decode(readValue(buffer)!);
      case 129: 
        return ListWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class ConnectionControl {
  /// Constructor for [ConnectionControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ConnectionControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ConnectionControlCodec();

  Future<BooleanWrapper> isConnected() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.isConnected', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }

  Future<void> disconnect() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.disconnect', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> sendRawPacket(ListWrapper arg_listOfBytes) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.sendRawPacket', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_listOfBytes]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> observeConnectionChanges() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.observeConnectionChanges', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> cancelObservingConnectionChanges() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ConnectionControl.cancelObservingConnectionChanges', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class RawIncomingPacketsControl {
  /// Constructor for [RawIncomingPacketsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  RawIncomingPacketsControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> observeIncomingPackets() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RawIncomingPacketsControl.observeIncomingPackets', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> cancelObservingIncomingPackets() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.RawIncomingPacketsControl.cancelObservingIncomingPackets', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _UiConnectionControlCodec extends StandardMessageCodec {
  const _UiConnectionControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// Connection methods that require UI reside in separate pigeon class.
/// This allows easier separation between background and UI methods.
class UiConnectionControl {
  /// Constructor for [UiConnectionControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  UiConnectionControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _UiConnectionControlCodec();

  Future<void> connectToWatch(StringWrapper arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UiConnectionControl.connectToWatch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_macAddress]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> unpairWatch(StringWrapper arg_macAddress) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.UiConnectionControl.unpairWatch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_macAddress]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _NotificationsControlCodec extends StandardMessageCodec {
  const _NotificationsControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NotifyingPackage) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return NotifyingPackage.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class NotificationsControl {
  /// Constructor for [NotificationsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  NotificationsControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _NotificationsControlCodec();

  Future<List<NotifyingPackage?>> getNotificationPackages() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.NotificationsControl.getNotificationPackages', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<NotifyingPackage?>();
    }
  }
}

class _IntentControlCodec extends StandardMessageCodec {
  const _IntentControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is OAuthResult) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return OAuthResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class IntentControl {
  /// Constructor for [IntentControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  IntentControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _IntentControlCodec();

  Future<void> notifyFlutterReadyForIntents() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IntentControl.notifyFlutterReadyForIntents', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> notifyFlutterNotReadyForIntents() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IntentControl.notifyFlutterNotReadyForIntents', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<OAuthResult> waitForOAuth() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.IntentControl.waitForOAuth', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as OAuthResult?)!;
    }
  }
}

class DebugControl {
  /// Constructor for [DebugControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  DebugControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> collectLogs(String arg_rwsId) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DebugControl.collectLogs', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_rwsId]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> getSensitiveLoggingEnabled() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DebugControl.getSensitiveLoggingEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> setSensitiveLoggingEnabled(bool arg_enabled) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.DebugControl.setSensitiveLoggingEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_enabled]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _TimelineControlCodec extends StandardMessageCodec {
  const _TimelineControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NumberWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is StringWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is TimelinePinPigeon) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return NumberWrapper.decode(readValue(buffer)!);
      case 129: 
        return StringWrapper.decode(readValue(buffer)!);
      case 130: 
        return TimelinePinPigeon.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class TimelineControl {
  /// Constructor for [TimelineControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  TimelineControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _TimelineControlCodec();

  Future<NumberWrapper> addPin(TimelinePinPigeon arg_pin) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineControl.addPin', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_pin]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> removePin(StringWrapper arg_pinUuid) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineControl.removePin', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_pinUuid]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> removeAllPins() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineControl.removeAllPins', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as NumberWrapper?)!;
    }
  }
}

class _PermissionCheckCodec extends StandardMessageCodec {
  const _PermissionCheckCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return BooleanWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class PermissionCheck {
  /// Constructor for [PermissionCheck].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PermissionCheck({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PermissionCheckCodec();

  Future<BooleanWrapper> hasLocationPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasLocationPermission', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> hasCalendarPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasCalendarPermission', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> hasNotificationAccess() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasNotificationAccess', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> hasBatteryExclusionEnabled() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasBatteryExclusionEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> hasCallsPermissions() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionCheck.hasCallsPermissions', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }
}

class _PermissionControlCodec extends StandardMessageCodec {
  const _PermissionControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is NumberWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return NumberWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class PermissionControl {
  /// Constructor for [PermissionControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PermissionControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PermissionControlCodec();

  Future<NumberWrapper> requestLocationPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestLocationPermission', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as NumberWrapper?)!;
    }
  }

  Future<NumberWrapper> requestCalendarPermission() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestCalendarPermission', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as NumberWrapper?)!;
    }
  }

  /// This can only be performed when at least one watch is paired
  Future<void> requestNotificationAccess() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestNotificationAccess', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  /// This can only be performed when at least one watch is paired
  Future<void> requestBatteryExclusion() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestBatteryExclusion', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  /// This can only be performed when at least one watch is paired
  Future<void> requestCallsPermissions() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestCallsPermissions', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<NumberWrapper> requestBluetoothPermissions() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.requestBluetoothPermissions', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as NumberWrapper?)!;
    }
  }

  Future<void> openPermissionSettings() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PermissionControl.openPermissionSettings', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _CalendarControlCodec extends StandardMessageCodec {
  const _CalendarControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is CalendarPigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return CalendarPigeon.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class CalendarControl {
  /// Constructor for [CalendarControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  CalendarControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _CalendarControlCodec();

  Future<void> requestCalendarSync(bool arg_forceResync) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CalendarControl.requestCalendarSync', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_forceResync]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> setCalendarSyncEnabled(bool arg_enabled) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CalendarControl.setCalendarSyncEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_enabled]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<bool> getCalendarSyncEnabled() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CalendarControl.getCalendarSyncEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as bool?)!;
    }
  }

  Future<void> deleteAllCalendarPins() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CalendarControl.deleteAllCalendarPins', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<List<CalendarPigeon?>> getCalendars() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CalendarControl.getCalendars', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as List<Object?>?)!.cast<CalendarPigeon?>();
    }
  }

  Future<void> setCalendarEnabled(int arg_id, bool arg_enabled) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.CalendarControl.setCalendarEnabled', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_id, arg_enabled]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _PigeonLoggerCodec extends StandardMessageCodec {
  const _PigeonLoggerCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class PigeonLogger {
  /// Constructor for [PigeonLogger].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PigeonLogger({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PigeonLoggerCodec();

  Future<void> v(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.v', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_message]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> d(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.d', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_message]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> i(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.i', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_message]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> w(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.w', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_message]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> e(StringWrapper arg_message) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PigeonLogger.e', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_message]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class TimelineSyncControl {
  /// Constructor for [TimelineSyncControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  TimelineSyncControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> syncTimelineToWatchLater() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.TimelineSyncControl.syncTimelineToWatchLater', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _WorkaroundsControlCodec extends StandardMessageCodec {
  const _WorkaroundsControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ListWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return ListWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class WorkaroundsControl {
  /// Constructor for [WorkaroundsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  WorkaroundsControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _WorkaroundsControlCodec();

  Future<ListWrapper> getNeededWorkarounds() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.WorkaroundsControl.getNeededWorkarounds', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as ListWrapper?)!;
    }
  }
}

class _AppInstallControlCodec extends StandardMessageCodec {
  const _AppInstallControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ListWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is NumberWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else if (value is PbwAppInfo) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else if (value is StringWrapper) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else if (value is WatchResource) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else if (value is WatchappInfo) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return ListWrapper.decode(readValue(buffer)!);
      case 129: 
        return NumberWrapper.decode(readValue(buffer)!);
      case 130: 
        return PbwAppInfo.decode(readValue(buffer)!);
      case 131: 
        return StringWrapper.decode(readValue(buffer)!);
      case 132: 
        return WatchResource.decode(readValue(buffer)!);
      case 133: 
        return WatchappInfo.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class AppInstallControl {
  /// Constructor for [AppInstallControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  AppInstallControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _AppInstallControlCodec();

  Future<PbwAppInfo> getAppInfo(StringWrapper arg_localPbwUri) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.getAppInfo', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_localPbwUri]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as PbwAppInfo?)!;
    }
  }

  Future<void> subscribeToAppStatus() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.subscribeToAppStatus', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> unsubscribeFromAppStatus() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.unsubscribeFromAppStatus', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<NumberWrapper> sendAppOrderToWatch(ListWrapper arg_uuidStringList) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppInstallControl.sendAppOrderToWatch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_uuidStringList]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as NumberWrapper?)!;
    }
  }
}

class _AppLifecycleControlCodec extends StandardMessageCodec {
  const _AppLifecycleControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is StringWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return BooleanWrapper.decode(readValue(buffer)!);
      case 129: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class AppLifecycleControl {
  /// Constructor for [AppLifecycleControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  AppLifecycleControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _AppLifecycleControlCodec();

  Future<BooleanWrapper> openAppOnTheWatch(StringWrapper arg_uuidString) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppLifecycleControl.openAppOnTheWatch', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_uuidString]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }
}

class _PackageDetailsCodec extends StandardMessageCodec {
  const _PackageDetailsCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AppEntriesPigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return AppEntriesPigeon.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class PackageDetails {
  /// Constructor for [PackageDetails].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  PackageDetails({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _PackageDetailsCodec();

  Future<AppEntriesPigeon> getPackageList() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.PackageDetails.getPackageList', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as AppEntriesPigeon?)!;
    }
  }
}

class _ScreenshotsControlCodec extends StandardMessageCodec {
  const _ScreenshotsControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is ScreenshotResult) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return ScreenshotResult.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class ScreenshotsControl {
  /// Constructor for [ScreenshotsControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  ScreenshotsControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _ScreenshotsControlCodec();

  Future<ScreenshotResult> takeWatchScreenshot() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.ScreenshotsControl.takeWatchScreenshot', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as ScreenshotResult?)!;
    }
  }
}

class AppLogControl {
  /// Constructor for [AppLogControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  AppLogControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = StandardMessageCodec();

  Future<void> startSendingLogs() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppLogControl.startSendingLogs', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> stopSendingLogs() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.AppLogControl.stopSendingLogs', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _FirmwareUpdateControlCodec extends StandardMessageCodec {
  const _FirmwareUpdateControlCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is BooleanWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is StringWrapper) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return BooleanWrapper.decode(readValue(buffer)!);
      case 129: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class FirmwareUpdateControl {
  /// Constructor for [FirmwareUpdateControl].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  FirmwareUpdateControl({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _FirmwareUpdateControlCodec();

  Future<BooleanWrapper> checkFirmwareCompatible(StringWrapper arg_fwUri) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.FirmwareUpdateControl.checkFirmwareCompatible', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_fwUri]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }

  Future<BooleanWrapper> beginFirmwareUpdate(StringWrapper arg_fwUri) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.FirmwareUpdateControl.beginFirmwareUpdate', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_fwUri]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else if (replyList[0] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyList[0] as BooleanWrapper?)!;
    }
  }
}

class _KeepUnusedHackCodec extends StandardMessageCodec {
  const _KeepUnusedHackCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is PebbleScanDevicePigeon) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else if (value is WatchResource) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return PebbleScanDevicePigeon.decode(readValue(buffer)!);
      case 129: 
        return WatchResource.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

/// This class will keep all classes that appear in lists from being deleted
/// by pigeon (they are not kept by default because pigeon does not support
/// generics in lists).
class KeepUnusedHack {
  /// Constructor for [KeepUnusedHack].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  KeepUnusedHack({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _KeepUnusedHackCodec();

  Future<void> keepPebbleScanDevicePigeon(PebbleScanDevicePigeon arg_cls) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KeepUnusedHack.keepPebbleScanDevicePigeon', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_cls]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> keepWatchResource(WatchResource arg_cls) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KeepUnusedHack.keepWatchResource', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_cls]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}

class _KMPApiCodec extends StandardMessageCodec {
  const _KMPApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is StringWrapper) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else {
      super.writeValue(buffer, value);
    }
  }

  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128: 
        return StringWrapper.decode(readValue(buffer)!);
      default:
        return super.readValueOfType(type, buffer);
    }
  }
}

class KMPApi {
  /// Constructor for [KMPApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  KMPApi({BinaryMessenger? binaryMessenger})
      : _binaryMessenger = binaryMessenger;
  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _KMPApiCodec();

  Future<void> updateToken(StringWrapper arg_token) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KMPApi.updateToken', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(<Object?>[arg_token]) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> openLockerView() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KMPApi.openLockerView', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }

  Future<void> openWatchesView() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KMPApi.openWatchesView', codec,
        binaryMessenger: _binaryMessenger);
    final List<Object?>? replyList =
        await channel.send(null) as List<Object?>?;
    if (replyList == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyList.length > 1) {
      throw PlatformException(
        code: replyList[0]! as String,
        message: replyList[1] as String?,
        details: replyList[2],
      );
    } else {
      return;
    }
  }
}
