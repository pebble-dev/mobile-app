// Autogenerated from Pigeon (v9.2.5), do not edit directly.
// See also: https://pub.dev/packages/pigeon

#import "Pigeons.h"
#import <Flutter/Flutter.h>

#if !__has_feature(objc_arc)
#error File requires ARC to be enabled.
#endif

static NSArray *wrapResult(id result, FlutterError *error) {
  if (error) {
    return @[
      error.code ?: [NSNull null], error.message ?: [NSNull null], error.details ?: [NSNull null]
    ];
  }
  return @[ result ?: [NSNull null] ];
}
static id GetNullableObjectAtIndex(NSArray *array, NSInteger key) {
  id result = array[key];
  return (result == [NSNull null]) ? nil : result;
}

@interface BooleanWrapper ()
+ (BooleanWrapper *)fromList:(NSArray *)list;
+ (nullable BooleanWrapper *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface NumberWrapper ()
+ (NumberWrapper *)fromList:(NSArray *)list;
+ (nullable NumberWrapper *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface StringWrapper ()
+ (StringWrapper *)fromList:(NSArray *)list;
+ (nullable StringWrapper *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface ListWrapper ()
+ (ListWrapper *)fromList:(NSArray *)list;
+ (nullable ListWrapper *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PebbleFirmwarePigeon ()
+ (PebbleFirmwarePigeon *)fromList:(NSArray *)list;
+ (nullable PebbleFirmwarePigeon *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PebbleDevicePigeon ()
+ (PebbleDevicePigeon *)fromList:(NSArray *)list;
+ (nullable PebbleDevicePigeon *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PebbleScanDevicePigeon ()
+ (PebbleScanDevicePigeon *)fromList:(NSArray *)list;
+ (nullable PebbleScanDevicePigeon *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface WatchConnectionStatePigeon ()
+ (WatchConnectionStatePigeon *)fromList:(NSArray *)list;
+ (nullable WatchConnectionStatePigeon *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface TimelinePinPigeon ()
+ (TimelinePinPigeon *)fromList:(NSArray *)list;
+ (nullable TimelinePinPigeon *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface NotifActionExecuteReq ()
+ (NotifActionExecuteReq *)fromList:(NSArray *)list;
+ (nullable NotifActionExecuteReq *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AppEntriesPigeon ()
+ (AppEntriesPigeon *)fromList:(NSArray *)list;
+ (nullable AppEntriesPigeon *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface PbwAppInfo ()
+ (PbwAppInfo *)fromList:(NSArray *)list;
+ (nullable PbwAppInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface WatchappInfo ()
+ (WatchappInfo *)fromList:(NSArray *)list;
+ (nullable WatchappInfo *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface WatchResource ()
+ (WatchResource *)fromList:(NSArray *)list;
+ (nullable WatchResource *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AppInstallStatus ()
+ (AppInstallStatus *)fromList:(NSArray *)list;
+ (nullable AppInstallStatus *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface ScreenshotResult ()
+ (ScreenshotResult *)fromList:(NSArray *)list;
+ (nullable ScreenshotResult *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface AppLogEntry ()
+ (AppLogEntry *)fromList:(NSArray *)list;
+ (nullable AppLogEntry *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface OAuthResult ()
+ (OAuthResult *)fromList:(NSArray *)list;
+ (nullable OAuthResult *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface NotifyingPackage ()
+ (NotifyingPackage *)fromList:(NSArray *)list;
+ (nullable NotifyingPackage *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@interface CalendarPigeon ()
+ (CalendarPigeon *)fromList:(NSArray *)list;
+ (nullable CalendarPigeon *)nullableFromList:(NSArray *)list;
- (NSArray *)toList;
@end

@implementation BooleanWrapper
+ (instancetype)makeWithValue:(nullable NSNumber *)value {
  BooleanWrapper* pigeonResult = [[BooleanWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (BooleanWrapper *)fromList:(NSArray *)list {
  BooleanWrapper *pigeonResult = [[BooleanWrapper alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable BooleanWrapper *)nullableFromList:(NSArray *)list {
  return (list) ? [BooleanWrapper fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.value ?: [NSNull null]),
  ];
}
@end

@implementation NumberWrapper
+ (instancetype)makeWithValue:(nullable NSNumber *)value {
  NumberWrapper* pigeonResult = [[NumberWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (NumberWrapper *)fromList:(NSArray *)list {
  NumberWrapper *pigeonResult = [[NumberWrapper alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable NumberWrapper *)nullableFromList:(NSArray *)list {
  return (list) ? [NumberWrapper fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.value ?: [NSNull null]),
  ];
}
@end

@implementation StringWrapper
+ (instancetype)makeWithValue:(nullable NSString *)value {
  StringWrapper* pigeonResult = [[StringWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (StringWrapper *)fromList:(NSArray *)list {
  StringWrapper *pigeonResult = [[StringWrapper alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable StringWrapper *)nullableFromList:(NSArray *)list {
  return (list) ? [StringWrapper fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.value ?: [NSNull null]),
  ];
}
@end

@implementation ListWrapper
+ (instancetype)makeWithValue:(nullable NSArray *)value {
  ListWrapper* pigeonResult = [[ListWrapper alloc] init];
  pigeonResult.value = value;
  return pigeonResult;
}
+ (ListWrapper *)fromList:(NSArray *)list {
  ListWrapper *pigeonResult = [[ListWrapper alloc] init];
  pigeonResult.value = GetNullableObjectAtIndex(list, 0);
  return pigeonResult;
}
+ (nullable ListWrapper *)nullableFromList:(NSArray *)list {
  return (list) ? [ListWrapper fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.value ?: [NSNull null]),
  ];
}
@end

@implementation PebbleFirmwarePigeon
+ (instancetype)makeWithTimestamp:(nullable NSNumber *)timestamp
    version:(nullable NSString *)version
    gitHash:(nullable NSString *)gitHash
    isRecovery:(nullable NSNumber *)isRecovery
    hardwarePlatform:(nullable NSNumber *)hardwarePlatform
    metadataVersion:(nullable NSNumber *)metadataVersion {
  PebbleFirmwarePigeon* pigeonResult = [[PebbleFirmwarePigeon alloc] init];
  pigeonResult.timestamp = timestamp;
  pigeonResult.version = version;
  pigeonResult.gitHash = gitHash;
  pigeonResult.isRecovery = isRecovery;
  pigeonResult.hardwarePlatform = hardwarePlatform;
  pigeonResult.metadataVersion = metadataVersion;
  return pigeonResult;
}
+ (PebbleFirmwarePigeon *)fromList:(NSArray *)list {
  PebbleFirmwarePigeon *pigeonResult = [[PebbleFirmwarePigeon alloc] init];
  pigeonResult.timestamp = GetNullableObjectAtIndex(list, 0);
  pigeonResult.version = GetNullableObjectAtIndex(list, 1);
  pigeonResult.gitHash = GetNullableObjectAtIndex(list, 2);
  pigeonResult.isRecovery = GetNullableObjectAtIndex(list, 3);
  pigeonResult.hardwarePlatform = GetNullableObjectAtIndex(list, 4);
  pigeonResult.metadataVersion = GetNullableObjectAtIndex(list, 5);
  return pigeonResult;
}
+ (nullable PebbleFirmwarePigeon *)nullableFromList:(NSArray *)list {
  return (list) ? [PebbleFirmwarePigeon fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.timestamp ?: [NSNull null]),
    (self.version ?: [NSNull null]),
    (self.gitHash ?: [NSNull null]),
    (self.isRecovery ?: [NSNull null]),
    (self.hardwarePlatform ?: [NSNull null]),
    (self.metadataVersion ?: [NSNull null]),
  ];
}
@end

@implementation PebbleDevicePigeon
+ (instancetype)makeWithName:(nullable NSString *)name
    address:(nullable NSString *)address
    runningFirmware:(nullable PebbleFirmwarePigeon *)runningFirmware
    recoveryFirmware:(nullable PebbleFirmwarePigeon *)recoveryFirmware
    model:(nullable NSNumber *)model
    bootloaderTimestamp:(nullable NSNumber *)bootloaderTimestamp
    board:(nullable NSString *)board
    serial:(nullable NSString *)serial
    language:(nullable NSString *)language
    languageVersion:(nullable NSNumber *)languageVersion
    isUnfaithful:(nullable NSNumber *)isUnfaithful {
  PebbleDevicePigeon* pigeonResult = [[PebbleDevicePigeon alloc] init];
  pigeonResult.name = name;
  pigeonResult.address = address;
  pigeonResult.runningFirmware = runningFirmware;
  pigeonResult.recoveryFirmware = recoveryFirmware;
  pigeonResult.model = model;
  pigeonResult.bootloaderTimestamp = bootloaderTimestamp;
  pigeonResult.board = board;
  pigeonResult.serial = serial;
  pigeonResult.language = language;
  pigeonResult.languageVersion = languageVersion;
  pigeonResult.isUnfaithful = isUnfaithful;
  return pigeonResult;
}
+ (PebbleDevicePigeon *)fromList:(NSArray *)list {
  PebbleDevicePigeon *pigeonResult = [[PebbleDevicePigeon alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  pigeonResult.address = GetNullableObjectAtIndex(list, 1);
  pigeonResult.runningFirmware = [PebbleFirmwarePigeon nullableFromList:(GetNullableObjectAtIndex(list, 2))];
  pigeonResult.recoveryFirmware = [PebbleFirmwarePigeon nullableFromList:(GetNullableObjectAtIndex(list, 3))];
  pigeonResult.model = GetNullableObjectAtIndex(list, 4);
  pigeonResult.bootloaderTimestamp = GetNullableObjectAtIndex(list, 5);
  pigeonResult.board = GetNullableObjectAtIndex(list, 6);
  pigeonResult.serial = GetNullableObjectAtIndex(list, 7);
  pigeonResult.language = GetNullableObjectAtIndex(list, 8);
  pigeonResult.languageVersion = GetNullableObjectAtIndex(list, 9);
  pigeonResult.isUnfaithful = GetNullableObjectAtIndex(list, 10);
  return pigeonResult;
}
+ (nullable PebbleDevicePigeon *)nullableFromList:(NSArray *)list {
  return (list) ? [PebbleDevicePigeon fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.name ?: [NSNull null]),
    (self.address ?: [NSNull null]),
    (self.runningFirmware ? [self.runningFirmware toList] : [NSNull null]),
    (self.recoveryFirmware ? [self.recoveryFirmware toList] : [NSNull null]),
    (self.model ?: [NSNull null]),
    (self.bootloaderTimestamp ?: [NSNull null]),
    (self.board ?: [NSNull null]),
    (self.serial ?: [NSNull null]),
    (self.language ?: [NSNull null]),
    (self.languageVersion ?: [NSNull null]),
    (self.isUnfaithful ?: [NSNull null]),
  ];
}
@end

@implementation PebbleScanDevicePigeon
+ (instancetype)makeWithName:(nullable NSString *)name
    address:(nullable NSString *)address
    version:(nullable NSString *)version
    serialNumber:(nullable NSString *)serialNumber
    color:(nullable NSNumber *)color
    runningPRF:(nullable NSNumber *)runningPRF
    firstUse:(nullable NSNumber *)firstUse {
  PebbleScanDevicePigeon* pigeonResult = [[PebbleScanDevicePigeon alloc] init];
  pigeonResult.name = name;
  pigeonResult.address = address;
  pigeonResult.version = version;
  pigeonResult.serialNumber = serialNumber;
  pigeonResult.color = color;
  pigeonResult.runningPRF = runningPRF;
  pigeonResult.firstUse = firstUse;
  return pigeonResult;
}
+ (PebbleScanDevicePigeon *)fromList:(NSArray *)list {
  PebbleScanDevicePigeon *pigeonResult = [[PebbleScanDevicePigeon alloc] init];
  pigeonResult.name = GetNullableObjectAtIndex(list, 0);
  pigeonResult.address = GetNullableObjectAtIndex(list, 1);
  pigeonResult.version = GetNullableObjectAtIndex(list, 2);
  pigeonResult.serialNumber = GetNullableObjectAtIndex(list, 3);
  pigeonResult.color = GetNullableObjectAtIndex(list, 4);
  pigeonResult.runningPRF = GetNullableObjectAtIndex(list, 5);
  pigeonResult.firstUse = GetNullableObjectAtIndex(list, 6);
  return pigeonResult;
}
+ (nullable PebbleScanDevicePigeon *)nullableFromList:(NSArray *)list {
  return (list) ? [PebbleScanDevicePigeon fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.name ?: [NSNull null]),
    (self.address ?: [NSNull null]),
    (self.version ?: [NSNull null]),
    (self.serialNumber ?: [NSNull null]),
    (self.color ?: [NSNull null]),
    (self.runningPRF ?: [NSNull null]),
    (self.firstUse ?: [NSNull null]),
  ];
}
@end

@implementation WatchConnectionStatePigeon
+ (instancetype)makeWithIsConnected:(NSNumber *)isConnected
    isConnecting:(NSNumber *)isConnecting
    currentWatchAddress:(nullable NSString *)currentWatchAddress
    currentConnectedWatch:(nullable PebbleDevicePigeon *)currentConnectedWatch {
  WatchConnectionStatePigeon* pigeonResult = [[WatchConnectionStatePigeon alloc] init];
  pigeonResult.isConnected = isConnected;
  pigeonResult.isConnecting = isConnecting;
  pigeonResult.currentWatchAddress = currentWatchAddress;
  pigeonResult.currentConnectedWatch = currentConnectedWatch;
  return pigeonResult;
}
+ (WatchConnectionStatePigeon *)fromList:(NSArray *)list {
  WatchConnectionStatePigeon *pigeonResult = [[WatchConnectionStatePigeon alloc] init];
  pigeonResult.isConnected = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.isConnected != nil, @"");
  pigeonResult.isConnecting = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.isConnecting != nil, @"");
  pigeonResult.currentWatchAddress = GetNullableObjectAtIndex(list, 2);
  pigeonResult.currentConnectedWatch = [PebbleDevicePigeon nullableFromList:(GetNullableObjectAtIndex(list, 3))];
  return pigeonResult;
}
+ (nullable WatchConnectionStatePigeon *)nullableFromList:(NSArray *)list {
  return (list) ? [WatchConnectionStatePigeon fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.isConnected ?: [NSNull null]),
    (self.isConnecting ?: [NSNull null]),
    (self.currentWatchAddress ?: [NSNull null]),
    (self.currentConnectedWatch ? [self.currentConnectedWatch toList] : [NSNull null]),
  ];
}
@end

@implementation TimelinePinPigeon
+ (instancetype)makeWithItemId:(nullable NSString *)itemId
    parentId:(nullable NSString *)parentId
    timestamp:(nullable NSNumber *)timestamp
    type:(nullable NSNumber *)type
    duration:(nullable NSNumber *)duration
    isVisible:(nullable NSNumber *)isVisible
    isFloating:(nullable NSNumber *)isFloating
    isAllDay:(nullable NSNumber *)isAllDay
    persistQuickView:(nullable NSNumber *)persistQuickView
    layout:(nullable NSNumber *)layout
    attributesJson:(nullable NSString *)attributesJson
    actionsJson:(nullable NSString *)actionsJson {
  TimelinePinPigeon* pigeonResult = [[TimelinePinPigeon alloc] init];
  pigeonResult.itemId = itemId;
  pigeonResult.parentId = parentId;
  pigeonResult.timestamp = timestamp;
  pigeonResult.type = type;
  pigeonResult.duration = duration;
  pigeonResult.isVisible = isVisible;
  pigeonResult.isFloating = isFloating;
  pigeonResult.isAllDay = isAllDay;
  pigeonResult.persistQuickView = persistQuickView;
  pigeonResult.layout = layout;
  pigeonResult.attributesJson = attributesJson;
  pigeonResult.actionsJson = actionsJson;
  return pigeonResult;
}
+ (TimelinePinPigeon *)fromList:(NSArray *)list {
  TimelinePinPigeon *pigeonResult = [[TimelinePinPigeon alloc] init];
  pigeonResult.itemId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.parentId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.timestamp = GetNullableObjectAtIndex(list, 2);
  pigeonResult.type = GetNullableObjectAtIndex(list, 3);
  pigeonResult.duration = GetNullableObjectAtIndex(list, 4);
  pigeonResult.isVisible = GetNullableObjectAtIndex(list, 5);
  pigeonResult.isFloating = GetNullableObjectAtIndex(list, 6);
  pigeonResult.isAllDay = GetNullableObjectAtIndex(list, 7);
  pigeonResult.persistQuickView = GetNullableObjectAtIndex(list, 8);
  pigeonResult.layout = GetNullableObjectAtIndex(list, 9);
  pigeonResult.attributesJson = GetNullableObjectAtIndex(list, 10);
  pigeonResult.actionsJson = GetNullableObjectAtIndex(list, 11);
  return pigeonResult;
}
+ (nullable TimelinePinPigeon *)nullableFromList:(NSArray *)list {
  return (list) ? [TimelinePinPigeon fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.itemId ?: [NSNull null]),
    (self.parentId ?: [NSNull null]),
    (self.timestamp ?: [NSNull null]),
    (self.type ?: [NSNull null]),
    (self.duration ?: [NSNull null]),
    (self.isVisible ?: [NSNull null]),
    (self.isFloating ?: [NSNull null]),
    (self.isAllDay ?: [NSNull null]),
    (self.persistQuickView ?: [NSNull null]),
    (self.layout ?: [NSNull null]),
    (self.attributesJson ?: [NSNull null]),
    (self.actionsJson ?: [NSNull null]),
  ];
}
@end

@implementation NotifActionExecuteReq
+ (instancetype)makeWithItemId:(nullable NSString *)itemId
    actionId:(nullable NSNumber *)actionId
    responseText:(nullable NSString *)responseText {
  NotifActionExecuteReq* pigeonResult = [[NotifActionExecuteReq alloc] init];
  pigeonResult.itemId = itemId;
  pigeonResult.actionId = actionId;
  pigeonResult.responseText = responseText;
  return pigeonResult;
}
+ (NotifActionExecuteReq *)fromList:(NSArray *)list {
  NotifActionExecuteReq *pigeonResult = [[NotifActionExecuteReq alloc] init];
  pigeonResult.itemId = GetNullableObjectAtIndex(list, 0);
  pigeonResult.actionId = GetNullableObjectAtIndex(list, 1);
  pigeonResult.responseText = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable NotifActionExecuteReq *)nullableFromList:(NSArray *)list {
  return (list) ? [NotifActionExecuteReq fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.itemId ?: [NSNull null]),
    (self.actionId ?: [NSNull null]),
    (self.responseText ?: [NSNull null]),
  ];
}
@end

@implementation AppEntriesPigeon
+ (instancetype)makeWithAppName:(nullable NSArray<NSString *> *)appName
    packageId:(nullable NSArray<NSString *> *)packageId {
  AppEntriesPigeon* pigeonResult = [[AppEntriesPigeon alloc] init];
  pigeonResult.appName = appName;
  pigeonResult.packageId = packageId;
  return pigeonResult;
}
+ (AppEntriesPigeon *)fromList:(NSArray *)list {
  AppEntriesPigeon *pigeonResult = [[AppEntriesPigeon alloc] init];
  pigeonResult.appName = GetNullableObjectAtIndex(list, 0);
  pigeonResult.packageId = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable AppEntriesPigeon *)nullableFromList:(NSArray *)list {
  return (list) ? [AppEntriesPigeon fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.appName ?: [NSNull null]),
    (self.packageId ?: [NSNull null]),
  ];
}
@end

@implementation PbwAppInfo
+ (instancetype)makeWithIsValid:(nullable NSNumber *)isValid
    uuid:(nullable NSString *)uuid
    shortName:(nullable NSString *)shortName
    longName:(nullable NSString *)longName
    companyName:(nullable NSString *)companyName
    versionCode:(nullable NSNumber *)versionCode
    versionLabel:(nullable NSString *)versionLabel
    appKeys:(nullable NSDictionary<NSString *, NSNumber *> *)appKeys
    capabilities:(nullable NSArray<NSString *> *)capabilities
    resources:(nullable NSArray<WatchResource *> *)resources
    sdkVersion:(nullable NSString *)sdkVersion
    targetPlatforms:(nullable NSArray<NSString *> *)targetPlatforms
    watchapp:(nullable WatchappInfo *)watchapp {
  PbwAppInfo* pigeonResult = [[PbwAppInfo alloc] init];
  pigeonResult.isValid = isValid;
  pigeonResult.uuid = uuid;
  pigeonResult.shortName = shortName;
  pigeonResult.longName = longName;
  pigeonResult.companyName = companyName;
  pigeonResult.versionCode = versionCode;
  pigeonResult.versionLabel = versionLabel;
  pigeonResult.appKeys = appKeys;
  pigeonResult.capabilities = capabilities;
  pigeonResult.resources = resources;
  pigeonResult.sdkVersion = sdkVersion;
  pigeonResult.targetPlatforms = targetPlatforms;
  pigeonResult.watchapp = watchapp;
  return pigeonResult;
}
+ (PbwAppInfo *)fromList:(NSArray *)list {
  PbwAppInfo *pigeonResult = [[PbwAppInfo alloc] init];
  pigeonResult.isValid = GetNullableObjectAtIndex(list, 0);
  pigeonResult.uuid = GetNullableObjectAtIndex(list, 1);
  pigeonResult.shortName = GetNullableObjectAtIndex(list, 2);
  pigeonResult.longName = GetNullableObjectAtIndex(list, 3);
  pigeonResult.companyName = GetNullableObjectAtIndex(list, 4);
  pigeonResult.versionCode = GetNullableObjectAtIndex(list, 5);
  pigeonResult.versionLabel = GetNullableObjectAtIndex(list, 6);
  pigeonResult.appKeys = GetNullableObjectAtIndex(list, 7);
  pigeonResult.capabilities = GetNullableObjectAtIndex(list, 8);
  pigeonResult.resources = GetNullableObjectAtIndex(list, 9);
  pigeonResult.sdkVersion = GetNullableObjectAtIndex(list, 10);
  pigeonResult.targetPlatforms = GetNullableObjectAtIndex(list, 11);
  pigeonResult.watchapp = [WatchappInfo nullableFromList:(GetNullableObjectAtIndex(list, 12))];
  return pigeonResult;
}
+ (nullable PbwAppInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [PbwAppInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.isValid ?: [NSNull null]),
    (self.uuid ?: [NSNull null]),
    (self.shortName ?: [NSNull null]),
    (self.longName ?: [NSNull null]),
    (self.companyName ?: [NSNull null]),
    (self.versionCode ?: [NSNull null]),
    (self.versionLabel ?: [NSNull null]),
    (self.appKeys ?: [NSNull null]),
    (self.capabilities ?: [NSNull null]),
    (self.resources ?: [NSNull null]),
    (self.sdkVersion ?: [NSNull null]),
    (self.targetPlatforms ?: [NSNull null]),
    (self.watchapp ? [self.watchapp toList] : [NSNull null]),
  ];
}
@end

@implementation WatchappInfo
+ (instancetype)makeWithWatchface:(nullable NSNumber *)watchface
    hiddenApp:(nullable NSNumber *)hiddenApp
    onlyShownOnCommunication:(nullable NSNumber *)onlyShownOnCommunication {
  WatchappInfo* pigeonResult = [[WatchappInfo alloc] init];
  pigeonResult.watchface = watchface;
  pigeonResult.hiddenApp = hiddenApp;
  pigeonResult.onlyShownOnCommunication = onlyShownOnCommunication;
  return pigeonResult;
}
+ (WatchappInfo *)fromList:(NSArray *)list {
  WatchappInfo *pigeonResult = [[WatchappInfo alloc] init];
  pigeonResult.watchface = GetNullableObjectAtIndex(list, 0);
  pigeonResult.hiddenApp = GetNullableObjectAtIndex(list, 1);
  pigeonResult.onlyShownOnCommunication = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable WatchappInfo *)nullableFromList:(NSArray *)list {
  return (list) ? [WatchappInfo fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.watchface ?: [NSNull null]),
    (self.hiddenApp ?: [NSNull null]),
    (self.onlyShownOnCommunication ?: [NSNull null]),
  ];
}
@end

@implementation WatchResource
+ (instancetype)makeWithFile:(nullable NSString *)file
    menuIcon:(nullable NSNumber *)menuIcon
    name:(nullable NSString *)name
    type:(nullable NSString *)type {
  WatchResource* pigeonResult = [[WatchResource alloc] init];
  pigeonResult.file = file;
  pigeonResult.menuIcon = menuIcon;
  pigeonResult.name = name;
  pigeonResult.type = type;
  return pigeonResult;
}
+ (WatchResource *)fromList:(NSArray *)list {
  WatchResource *pigeonResult = [[WatchResource alloc] init];
  pigeonResult.file = GetNullableObjectAtIndex(list, 0);
  pigeonResult.menuIcon = GetNullableObjectAtIndex(list, 1);
  pigeonResult.name = GetNullableObjectAtIndex(list, 2);
  pigeonResult.type = GetNullableObjectAtIndex(list, 3);
  return pigeonResult;
}
+ (nullable WatchResource *)nullableFromList:(NSArray *)list {
  return (list) ? [WatchResource fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.file ?: [NSNull null]),
    (self.menuIcon ?: [NSNull null]),
    (self.name ?: [NSNull null]),
    (self.type ?: [NSNull null]),
  ];
}
@end

@implementation AppInstallStatus
+ (instancetype)makeWithProgress:(NSNumber *)progress
    isInstalling:(NSNumber *)isInstalling {
  AppInstallStatus* pigeonResult = [[AppInstallStatus alloc] init];
  pigeonResult.progress = progress;
  pigeonResult.isInstalling = isInstalling;
  return pigeonResult;
}
+ (AppInstallStatus *)fromList:(NSArray *)list {
  AppInstallStatus *pigeonResult = [[AppInstallStatus alloc] init];
  pigeonResult.progress = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.progress != nil, @"");
  pigeonResult.isInstalling = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.isInstalling != nil, @"");
  return pigeonResult;
}
+ (nullable AppInstallStatus *)nullableFromList:(NSArray *)list {
  return (list) ? [AppInstallStatus fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.progress ?: [NSNull null]),
    (self.isInstalling ?: [NSNull null]),
  ];
}
@end

@implementation ScreenshotResult
+ (instancetype)makeWithSuccess:(NSNumber *)success
    imagePath:(nullable NSString *)imagePath {
  ScreenshotResult* pigeonResult = [[ScreenshotResult alloc] init];
  pigeonResult.success = success;
  pigeonResult.imagePath = imagePath;
  return pigeonResult;
}
+ (ScreenshotResult *)fromList:(NSArray *)list {
  ScreenshotResult *pigeonResult = [[ScreenshotResult alloc] init];
  pigeonResult.success = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.success != nil, @"");
  pigeonResult.imagePath = GetNullableObjectAtIndex(list, 1);
  return pigeonResult;
}
+ (nullable ScreenshotResult *)nullableFromList:(NSArray *)list {
  return (list) ? [ScreenshotResult fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.success ?: [NSNull null]),
    (self.imagePath ?: [NSNull null]),
  ];
}
@end

@implementation AppLogEntry
+ (instancetype)makeWithUuid:(NSString *)uuid
    timestamp:(NSNumber *)timestamp
    level:(NSNumber *)level
    lineNumber:(NSNumber *)lineNumber
    filename:(NSString *)filename
    message:(NSString *)message {
  AppLogEntry* pigeonResult = [[AppLogEntry alloc] init];
  pigeonResult.uuid = uuid;
  pigeonResult.timestamp = timestamp;
  pigeonResult.level = level;
  pigeonResult.lineNumber = lineNumber;
  pigeonResult.filename = filename;
  pigeonResult.message = message;
  return pigeonResult;
}
+ (AppLogEntry *)fromList:(NSArray *)list {
  AppLogEntry *pigeonResult = [[AppLogEntry alloc] init];
  pigeonResult.uuid = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.uuid != nil, @"");
  pigeonResult.timestamp = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.timestamp != nil, @"");
  pigeonResult.level = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.level != nil, @"");
  pigeonResult.lineNumber = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.lineNumber != nil, @"");
  pigeonResult.filename = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.filename != nil, @"");
  pigeonResult.message = GetNullableObjectAtIndex(list, 5);
  NSAssert(pigeonResult.message != nil, @"");
  return pigeonResult;
}
+ (nullable AppLogEntry *)nullableFromList:(NSArray *)list {
  return (list) ? [AppLogEntry fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.uuid ?: [NSNull null]),
    (self.timestamp ?: [NSNull null]),
    (self.level ?: [NSNull null]),
    (self.lineNumber ?: [NSNull null]),
    (self.filename ?: [NSNull null]),
    (self.message ?: [NSNull null]),
  ];
}
@end

@implementation OAuthResult
+ (instancetype)makeWithCode:(nullable NSString *)code
    state:(nullable NSString *)state
    error:(nullable NSString *)error {
  OAuthResult* pigeonResult = [[OAuthResult alloc] init];
  pigeonResult.code = code;
  pigeonResult.state = state;
  pigeonResult.error = error;
  return pigeonResult;
}
+ (OAuthResult *)fromList:(NSArray *)list {
  OAuthResult *pigeonResult = [[OAuthResult alloc] init];
  pigeonResult.code = GetNullableObjectAtIndex(list, 0);
  pigeonResult.state = GetNullableObjectAtIndex(list, 1);
  pigeonResult.error = GetNullableObjectAtIndex(list, 2);
  return pigeonResult;
}
+ (nullable OAuthResult *)nullableFromList:(NSArray *)list {
  return (list) ? [OAuthResult fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.code ?: [NSNull null]),
    (self.state ?: [NSNull null]),
    (self.error ?: [NSNull null]),
  ];
}
@end

@implementation NotifyingPackage
+ (instancetype)makeWithPackageId:(NSString *)packageId
    packageName:(NSString *)packageName {
  NotifyingPackage* pigeonResult = [[NotifyingPackage alloc] init];
  pigeonResult.packageId = packageId;
  pigeonResult.packageName = packageName;
  return pigeonResult;
}
+ (NotifyingPackage *)fromList:(NSArray *)list {
  NotifyingPackage *pigeonResult = [[NotifyingPackage alloc] init];
  pigeonResult.packageId = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.packageId != nil, @"");
  pigeonResult.packageName = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.packageName != nil, @"");
  return pigeonResult;
}
+ (nullable NotifyingPackage *)nullableFromList:(NSArray *)list {
  return (list) ? [NotifyingPackage fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.packageId ?: [NSNull null]),
    (self.packageName ?: [NSNull null]),
  ];
}
@end

@implementation CalendarPigeon
+ (instancetype)makeWithId:(NSNumber *)id
    account:(NSString *)account
    name:(NSString *)name
    color:(NSNumber *)color
    enabled:(NSNumber *)enabled {
  CalendarPigeon* pigeonResult = [[CalendarPigeon alloc] init];
  pigeonResult.id = id;
  pigeonResult.account = account;
  pigeonResult.name = name;
  pigeonResult.color = color;
  pigeonResult.enabled = enabled;
  return pigeonResult;
}
+ (CalendarPigeon *)fromList:(NSArray *)list {
  CalendarPigeon *pigeonResult = [[CalendarPigeon alloc] init];
  pigeonResult.id = GetNullableObjectAtIndex(list, 0);
  NSAssert(pigeonResult.id != nil, @"");
  pigeonResult.account = GetNullableObjectAtIndex(list, 1);
  NSAssert(pigeonResult.account != nil, @"");
  pigeonResult.name = GetNullableObjectAtIndex(list, 2);
  NSAssert(pigeonResult.name != nil, @"");
  pigeonResult.color = GetNullableObjectAtIndex(list, 3);
  NSAssert(pigeonResult.color != nil, @"");
  pigeonResult.enabled = GetNullableObjectAtIndex(list, 4);
  NSAssert(pigeonResult.enabled != nil, @"");
  return pigeonResult;
}
+ (nullable CalendarPigeon *)nullableFromList:(NSArray *)list {
  return (list) ? [CalendarPigeon fromList:list] : nil;
}
- (NSArray *)toList {
  return @[
    (self.id ?: [NSNull null]),
    (self.account ?: [NSNull null]),
    (self.name ?: [NSNull null]),
    (self.color ?: [NSNull null]),
    (self.enabled ?: [NSNull null]),
  ];
}
@end

@interface CalendarCallbacksCodecReader : FlutterStandardReader
@end
@implementation CalendarCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [CalendarPigeon fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface CalendarCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation CalendarCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[CalendarPigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface CalendarCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CalendarCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CalendarCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CalendarCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *CalendarCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    CalendarCallbacksCodecReaderWriter *readerWriter = [[CalendarCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface CalendarCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation CalendarCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onCalendarListUpdatedCalendars:(NSArray<CalendarPigeon *> *)arg_calendars completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.CalendarCallbacks.onCalendarListUpdated"
      binaryMessenger:self.binaryMessenger
      codec:CalendarCallbacksGetCodec()];
  [channel sendMessage:@[arg_calendars ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface ScanCallbacksCodecReader : FlutterStandardReader
@end
@implementation ScanCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [PebbleScanDevicePigeon fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface ScanCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation ScanCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PebbleScanDevicePigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface ScanCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ScanCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ScanCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ScanCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ScanCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    ScanCallbacksCodecReaderWriter *readerWriter = [[ScanCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface ScanCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation ScanCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onScanUpdatePebbles:(NSArray<PebbleScanDevicePigeon *> *)arg_pebbles completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ScanCallbacks.onScanUpdate"
      binaryMessenger:self.binaryMessenger
      codec:ScanCallbacksGetCodec()];
  [channel sendMessage:@[arg_pebbles ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onScanStartedWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ScanCallbacks.onScanStarted"
      binaryMessenger:self.binaryMessenger
      codec:ScanCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onScanStoppedWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ScanCallbacks.onScanStopped"
      binaryMessenger:self.binaryMessenger
      codec:ScanCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface ConnectionCallbacksCodecReader : FlutterStandardReader
@end
@implementation ConnectionCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [PebbleDevicePigeon fromList:[self readValue]];
    case 129: 
      return [PebbleFirmwarePigeon fromList:[self readValue]];
    case 130: 
      return [WatchConnectionStatePigeon fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface ConnectionCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation ConnectionCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PebbleDevicePigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PebbleFirmwarePigeon class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[WatchConnectionStatePigeon class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface ConnectionCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ConnectionCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ConnectionCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ConnectionCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ConnectionCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    ConnectionCallbacksCodecReaderWriter *readerWriter = [[ConnectionCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface ConnectionCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation ConnectionCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onWatchConnectionStateChangedNewState:(WatchConnectionStatePigeon *)arg_newState completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.ConnectionCallbacks.onWatchConnectionStateChanged"
      binaryMessenger:self.binaryMessenger
      codec:ConnectionCallbacksGetCodec()];
  [channel sendMessage:@[arg_newState ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface RawIncomingPacketsCallbacksCodecReader : FlutterStandardReader
@end
@implementation RawIncomingPacketsCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [ListWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface RawIncomingPacketsCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation RawIncomingPacketsCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface RawIncomingPacketsCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation RawIncomingPacketsCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[RawIncomingPacketsCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[RawIncomingPacketsCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *RawIncomingPacketsCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    RawIncomingPacketsCallbacksCodecReaderWriter *readerWriter = [[RawIncomingPacketsCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface RawIncomingPacketsCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation RawIncomingPacketsCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onPacketReceivedListOfBytes:(ListWrapper *)arg_listOfBytes completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.RawIncomingPacketsCallbacks.onPacketReceived"
      binaryMessenger:self.binaryMessenger
      codec:RawIncomingPacketsCallbacksGetCodec()];
  [channel sendMessage:@[arg_listOfBytes ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface PairCallbacksCodecReader : FlutterStandardReader
@end
@implementation PairCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface PairCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation PairCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface PairCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PairCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PairCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PairCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PairCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    PairCallbacksCodecReaderWriter *readerWriter = [[PairCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface PairCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation PairCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onWatchPairCompleteAddress:(StringWrapper *)arg_address completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.PairCallbacks.onWatchPairComplete"
      binaryMessenger:self.binaryMessenger
      codec:PairCallbacksGetCodec()];
  [channel sendMessage:@[arg_address ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface IntentCallbacksCodecReader : FlutterStandardReader
@end
@implementation IntentCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface IntentCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation IntentCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface IntentCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation IntentCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[IntentCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[IntentCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *IntentCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    IntentCallbacksCodecReaderWriter *readerWriter = [[IntentCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface IntentCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation IntentCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)openUriUri:(StringWrapper *)arg_uri completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.IntentCallbacks.openUri"
      binaryMessenger:self.binaryMessenger
      codec:IntentCallbacksGetCodec()];
  [channel sendMessage:@[arg_uri ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface AppInstallStatusCallbacksCodecReader : FlutterStandardReader
@end
@implementation AppInstallStatusCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [AppInstallStatus fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface AppInstallStatusCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation AppInstallStatusCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AppInstallStatus class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface AppInstallStatusCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppInstallStatusCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppInstallStatusCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppInstallStatusCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppInstallStatusCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    AppInstallStatusCallbacksCodecReaderWriter *readerWriter = [[AppInstallStatusCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface AppInstallStatusCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation AppInstallStatusCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onStatusUpdatedStatus:(AppInstallStatus *)arg_status completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.AppInstallStatusCallbacks.onStatusUpdated"
      binaryMessenger:self.binaryMessenger
      codec:AppInstallStatusCallbacksGetCodec()];
  [channel sendMessage:@[arg_status ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface AppLogCallbacksCodecReader : FlutterStandardReader
@end
@implementation AppLogCallbacksCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [AppLogEntry fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface AppLogCallbacksCodecWriter : FlutterStandardWriter
@end
@implementation AppLogCallbacksCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AppLogEntry class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface AppLogCallbacksCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppLogCallbacksCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppLogCallbacksCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppLogCallbacksCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppLogCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    AppLogCallbacksCodecReaderWriter *readerWriter = [[AppLogCallbacksCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

@interface AppLogCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation AppLogCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onLogReceivedEntry:(AppLogEntry *)arg_entry completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.AppLogCallbacks.onLogReceived"
      binaryMessenger:self.binaryMessenger
      codec:AppLogCallbacksGetCodec()];
  [channel sendMessage:@[arg_entry ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
@end

NSObject<FlutterMessageCodec> *FirmwareUpdateCallbacksGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

@interface FirmwareUpdateCallbacks ()
@property(nonatomic, strong) NSObject<FlutterBinaryMessenger> *binaryMessenger;
@end

@implementation FirmwareUpdateCallbacks

- (instancetype)initWithBinaryMessenger:(NSObject<FlutterBinaryMessenger> *)binaryMessenger {
  self = [super init];
  if (self) {
    _binaryMessenger = binaryMessenger;
  }
  return self;
}
- (void)onFirmwareUpdateStartedWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateStarted"
      binaryMessenger:self.binaryMessenger
      codec:FirmwareUpdateCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onFirmwareUpdateProgressProgress:(NSNumber *)arg_progress completion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateProgress"
      binaryMessenger:self.binaryMessenger
      codec:FirmwareUpdateCallbacksGetCodec()];
  [channel sendMessage:@[arg_progress ?: [NSNull null]] reply:^(id reply) {
    completion(nil);
  }];
}
- (void)onFirmwareUpdateFinishedWithCompletion:(void (^)(FlutterError *_Nullable))completion {
  FlutterBasicMessageChannel *channel =
    [FlutterBasicMessageChannel
      messageChannelWithName:@"dev.flutter.pigeon.FirmwareUpdateCallbacks.onFirmwareUpdateFinished"
      binaryMessenger:self.binaryMessenger
      codec:FirmwareUpdateCallbacksGetCodec()];
  [channel sendMessage:nil reply:^(id reply) {
    completion(nil);
  }];
}
@end

@interface NotificationUtilsCodecReader : FlutterStandardReader
@end
@implementation NotificationUtilsCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [BooleanWrapper fromList:[self readValue]];
    case 129: 
      return [NotifActionExecuteReq fromList:[self readValue]];
    case 130: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface NotificationUtilsCodecWriter : FlutterStandardWriter
@end
@implementation NotificationUtilsCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[NotifActionExecuteReq class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface NotificationUtilsCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NotificationUtilsCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NotificationUtilsCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NotificationUtilsCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NotificationUtilsGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    NotificationUtilsCodecReaderWriter *readerWriter = [[NotificationUtilsCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void NotificationUtilsSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<NotificationUtils> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.dismissNotification"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dismissNotificationItemId:completion:)], @"NotificationUtils api (%@) doesn't respond to @selector(dismissNotificationItemId:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_itemId = GetNullableObjectAtIndex(args, 0);
        [api dismissNotificationItemId:arg_itemId completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.dismissNotificationWatch"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dismissNotificationWatchItemId:error:)], @"NotificationUtils api (%@) doesn't respond to @selector(dismissNotificationWatchItemId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_itemId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api dismissNotificationWatchItemId:arg_itemId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.openNotification"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openNotificationItemId:error:)], @"NotificationUtils api (%@) doesn't respond to @selector(openNotificationItemId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_itemId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api openNotificationItemId:arg_itemId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationUtils.executeAction"
        binaryMessenger:binaryMessenger
        codec:NotificationUtilsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(executeActionAction:error:)], @"NotificationUtils api (%@) doesn't respond to @selector(executeActionAction:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NotifActionExecuteReq *arg_action = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api executeActionAction:arg_action error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *ScanControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void ScanControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<ScanControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ScanControl.startBleScan"
        binaryMessenger:binaryMessenger
        codec:ScanControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startBleScanWithError:)], @"ScanControl api (%@) doesn't respond to @selector(startBleScanWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api startBleScanWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ScanControl.startClassicScan"
        binaryMessenger:binaryMessenger
        codec:ScanControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startClassicScanWithError:)], @"ScanControl api (%@) doesn't respond to @selector(startClassicScanWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api startClassicScanWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface ConnectionControlCodecReader : FlutterStandardReader
@end
@implementation ConnectionControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [BooleanWrapper fromList:[self readValue]];
    case 129: 
      return [ListWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface ConnectionControlCodecWriter : FlutterStandardWriter
@end
@implementation ConnectionControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface ConnectionControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ConnectionControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ConnectionControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ConnectionControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ConnectionControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    ConnectionControlCodecReaderWriter *readerWriter = [[ConnectionControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void ConnectionControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<ConnectionControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.isConnected"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(isConnectedWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(isConnectedWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api isConnectedWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.disconnect"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(disconnectWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(disconnectWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api disconnectWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.sendRawPacket"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(sendRawPacketListOfBytes:error:)], @"ConnectionControl api (%@) doesn't respond to @selector(sendRawPacketListOfBytes:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        ListWrapper *arg_listOfBytes = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api sendRawPacketListOfBytes:arg_listOfBytes error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.observeConnectionChanges"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(observeConnectionChangesWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(observeConnectionChangesWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api observeConnectionChangesWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ConnectionControl.cancelObservingConnectionChanges"
        binaryMessenger:binaryMessenger
        codec:ConnectionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelObservingConnectionChangesWithError:)], @"ConnectionControl api (%@) doesn't respond to @selector(cancelObservingConnectionChangesWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelObservingConnectionChangesWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *RawIncomingPacketsControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void RawIncomingPacketsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<RawIncomingPacketsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.RawIncomingPacketsControl.observeIncomingPackets"
        binaryMessenger:binaryMessenger
        codec:RawIncomingPacketsControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(observeIncomingPacketsWithError:)], @"RawIncomingPacketsControl api (%@) doesn't respond to @selector(observeIncomingPacketsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api observeIncomingPacketsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.RawIncomingPacketsControl.cancelObservingIncomingPackets"
        binaryMessenger:binaryMessenger
        codec:RawIncomingPacketsControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(cancelObservingIncomingPacketsWithError:)], @"RawIncomingPacketsControl api (%@) doesn't respond to @selector(cancelObservingIncomingPacketsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api cancelObservingIncomingPacketsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface UiConnectionControlCodecReader : FlutterStandardReader
@end
@implementation UiConnectionControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface UiConnectionControlCodecWriter : FlutterStandardWriter
@end
@implementation UiConnectionControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface UiConnectionControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation UiConnectionControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[UiConnectionControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[UiConnectionControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *UiConnectionControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    UiConnectionControlCodecReaderWriter *readerWriter = [[UiConnectionControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void UiConnectionControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<UiConnectionControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.UiConnectionControl.connectToWatch"
        binaryMessenger:binaryMessenger
        codec:UiConnectionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(connectToWatchMacAddress:error:)], @"UiConnectionControl api (%@) doesn't respond to @selector(connectToWatchMacAddress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_macAddress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api connectToWatchMacAddress:arg_macAddress error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.UiConnectionControl.unpairWatch"
        binaryMessenger:binaryMessenger
        codec:UiConnectionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unpairWatchMacAddress:error:)], @"UiConnectionControl api (%@) doesn't respond to @selector(unpairWatchMacAddress:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_macAddress = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api unpairWatchMacAddress:arg_macAddress error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface NotificationsControlCodecReader : FlutterStandardReader
@end
@implementation NotificationsControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [NotifyingPackage fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface NotificationsControlCodecWriter : FlutterStandardWriter
@end
@implementation NotificationsControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[NotifyingPackage class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface NotificationsControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation NotificationsControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[NotificationsControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[NotificationsControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *NotificationsControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    NotificationsControlCodecReaderWriter *readerWriter = [[NotificationsControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void NotificationsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<NotificationsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.NotificationsControl.getNotificationPackages"
        binaryMessenger:binaryMessenger
        codec:NotificationsControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getNotificationPackagesWithCompletion:)], @"NotificationsControl api (%@) doesn't respond to @selector(getNotificationPackagesWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getNotificationPackagesWithCompletion:^(NSArray<NotifyingPackage *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface IntentControlCodecReader : FlutterStandardReader
@end
@implementation IntentControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [OAuthResult fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface IntentControlCodecWriter : FlutterStandardWriter
@end
@implementation IntentControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[OAuthResult class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface IntentControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation IntentControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[IntentControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[IntentControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *IntentControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    IntentControlCodecReaderWriter *readerWriter = [[IntentControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void IntentControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<IntentControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.IntentControl.notifyFlutterReadyForIntents"
        binaryMessenger:binaryMessenger
        codec:IntentControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(notifyFlutterReadyForIntentsWithError:)], @"IntentControl api (%@) doesn't respond to @selector(notifyFlutterReadyForIntentsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api notifyFlutterReadyForIntentsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.IntentControl.notifyFlutterNotReadyForIntents"
        binaryMessenger:binaryMessenger
        codec:IntentControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(notifyFlutterNotReadyForIntentsWithError:)], @"IntentControl api (%@) doesn't respond to @selector(notifyFlutterNotReadyForIntentsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api notifyFlutterNotReadyForIntentsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.IntentControl.waitForOAuth"
        binaryMessenger:binaryMessenger
        codec:IntentControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(waitForOAuthWithCompletion:)], @"IntentControl api (%@) doesn't respond to @selector(waitForOAuthWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api waitForOAuthWithCompletion:^(OAuthResult *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *DebugControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void DebugControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<DebugControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.DebugControl.collectLogs"
        binaryMessenger:binaryMessenger
        codec:DebugControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(collectLogsRwsId:error:)], @"DebugControl api (%@) doesn't respond to @selector(collectLogsRwsId:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSString *arg_rwsId = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api collectLogsRwsId:arg_rwsId error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.DebugControl.getSensitiveLoggingEnabled"
        binaryMessenger:binaryMessenger
        codec:DebugControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getSensitiveLoggingEnabledWithCompletion:)], @"DebugControl api (%@) doesn't respond to @selector(getSensitiveLoggingEnabledWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getSensitiveLoggingEnabledWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.DebugControl.setSensitiveLoggingEnabled"
        binaryMessenger:binaryMessenger
        codec:DebugControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setSensitiveLoggingEnabledEnabled:completion:)], @"DebugControl api (%@) doesn't respond to @selector(setSensitiveLoggingEnabledEnabled:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_enabled = GetNullableObjectAtIndex(args, 0);
        [api setSensitiveLoggingEnabledEnabled:arg_enabled completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface TimelineControlCodecReader : FlutterStandardReader
@end
@implementation TimelineControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [NumberWrapper fromList:[self readValue]];
    case 129: 
      return [StringWrapper fromList:[self readValue]];
    case 130: 
      return [TimelinePinPigeon fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface TimelineControlCodecWriter : FlutterStandardWriter
@end
@implementation TimelineControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[TimelinePinPigeon class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface TimelineControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation TimelineControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[TimelineControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[TimelineControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *TimelineControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    TimelineControlCodecReaderWriter *readerWriter = [[TimelineControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void TimelineControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<TimelineControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineControl.addPin"
        binaryMessenger:binaryMessenger
        codec:TimelineControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(addPinPin:completion:)], @"TimelineControl api (%@) doesn't respond to @selector(addPinPin:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        TimelinePinPigeon *arg_pin = GetNullableObjectAtIndex(args, 0);
        [api addPinPin:arg_pin completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineControl.removePin"
        binaryMessenger:binaryMessenger
        codec:TimelineControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removePinPinUuid:completion:)], @"TimelineControl api (%@) doesn't respond to @selector(removePinPinUuid:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_pinUuid = GetNullableObjectAtIndex(args, 0);
        [api removePinPinUuid:arg_pinUuid completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineControl.removeAllPins"
        binaryMessenger:binaryMessenger
        codec:TimelineControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(removeAllPinsWithCompletion:)], @"TimelineControl api (%@) doesn't respond to @selector(removeAllPinsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api removeAllPinsWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PermissionCheckCodecReader : FlutterStandardReader
@end
@implementation PermissionCheckCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [BooleanWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface PermissionCheckCodecWriter : FlutterStandardWriter
@end
@implementation PermissionCheckCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface PermissionCheckCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PermissionCheckCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PermissionCheckCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PermissionCheckCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PermissionCheckGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    PermissionCheckCodecReaderWriter *readerWriter = [[PermissionCheckCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void PermissionCheckSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PermissionCheck> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasLocationPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasLocationPermissionWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasLocationPermissionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasLocationPermissionWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasCalendarPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasCalendarPermissionWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasCalendarPermissionWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasCalendarPermissionWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasNotificationAccess"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasNotificationAccessWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasNotificationAccessWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasNotificationAccessWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasBatteryExclusionEnabled"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasBatteryExclusionEnabledWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasBatteryExclusionEnabledWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasBatteryExclusionEnabledWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionCheck.hasCallsPermissions"
        binaryMessenger:binaryMessenger
        codec:PermissionCheckGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(hasCallsPermissionsWithError:)], @"PermissionCheck api (%@) doesn't respond to @selector(hasCallsPermissionsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        BooleanWrapper *output = [api hasCallsPermissionsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PermissionControlCodecReader : FlutterStandardReader
@end
@implementation PermissionControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [NumberWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface PermissionControlCodecWriter : FlutterStandardWriter
@end
@implementation PermissionControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface PermissionControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PermissionControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PermissionControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PermissionControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PermissionControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    PermissionControlCodecReaderWriter *readerWriter = [[PermissionControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void PermissionControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PermissionControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestLocationPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestLocationPermissionWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestLocationPermissionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestLocationPermissionWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestCalendarPermission"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestCalendarPermissionWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestCalendarPermissionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestCalendarPermissionWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// This can only be performed when at least one watch is paired
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestNotificationAccess"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestNotificationAccessWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestNotificationAccessWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestNotificationAccessWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// This can only be performed when at least one watch is paired
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestBatteryExclusion"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestBatteryExclusionWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestBatteryExclusionWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestBatteryExclusionWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  /// This can only be performed when at least one watch is paired
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestCallsPermissions"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestCallsPermissionsWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestCallsPermissionsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestCallsPermissionsWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.requestBluetoothPermissions"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestBluetoothPermissionsWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(requestBluetoothPermissionsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api requestBluetoothPermissionsWithCompletion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PermissionControl.openPermissionSettings"
        binaryMessenger:binaryMessenger
        codec:PermissionControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openPermissionSettingsWithCompletion:)], @"PermissionControl api (%@) doesn't respond to @selector(openPermissionSettingsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api openPermissionSettingsWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface CalendarControlCodecReader : FlutterStandardReader
@end
@implementation CalendarControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [CalendarPigeon fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface CalendarControlCodecWriter : FlutterStandardWriter
@end
@implementation CalendarControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[CalendarPigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface CalendarControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation CalendarControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[CalendarControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[CalendarControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *CalendarControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    CalendarControlCodecReaderWriter *readerWriter = [[CalendarControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void CalendarControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<CalendarControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CalendarControl.requestCalendarSync"
        binaryMessenger:binaryMessenger
        codec:CalendarControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(requestCalendarSyncForceResync:error:)], @"CalendarControl api (%@) doesn't respond to @selector(requestCalendarSyncForceResync:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_forceResync = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api requestCalendarSyncForceResync:arg_forceResync error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CalendarControl.setCalendarSyncEnabled"
        binaryMessenger:binaryMessenger
        codec:CalendarControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setCalendarSyncEnabledEnabled:completion:)], @"CalendarControl api (%@) doesn't respond to @selector(setCalendarSyncEnabledEnabled:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_enabled = GetNullableObjectAtIndex(args, 0);
        [api setCalendarSyncEnabledEnabled:arg_enabled completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CalendarControl.getCalendarSyncEnabled"
        binaryMessenger:binaryMessenger
        codec:CalendarControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getCalendarSyncEnabledWithCompletion:)], @"CalendarControl api (%@) doesn't respond to @selector(getCalendarSyncEnabledWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getCalendarSyncEnabledWithCompletion:^(NSNumber *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CalendarControl.deleteAllCalendarPins"
        binaryMessenger:binaryMessenger
        codec:CalendarControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(deleteAllCalendarPinsWithCompletion:)], @"CalendarControl api (%@) doesn't respond to @selector(deleteAllCalendarPinsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api deleteAllCalendarPinsWithCompletion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CalendarControl.getCalendars"
        binaryMessenger:binaryMessenger
        codec:CalendarControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getCalendarsWithCompletion:)], @"CalendarControl api (%@) doesn't respond to @selector(getCalendarsWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api getCalendarsWithCompletion:^(NSArray<CalendarPigeon *> *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.CalendarControl.setCalendarEnabled"
        binaryMessenger:binaryMessenger
        codec:CalendarControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(setCalendarEnabledId:enabled:completion:)], @"CalendarControl api (%@) doesn't respond to @selector(setCalendarEnabledId:enabled:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        NSNumber *arg_id = GetNullableObjectAtIndex(args, 0);
        NSNumber *arg_enabled = GetNullableObjectAtIndex(args, 1);
        [api setCalendarEnabledId:arg_id enabled:arg_enabled completion:^(FlutterError *_Nullable error) {
          callback(wrapResult(nil, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PigeonLoggerCodecReader : FlutterStandardReader
@end
@implementation PigeonLoggerCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface PigeonLoggerCodecWriter : FlutterStandardWriter
@end
@implementation PigeonLoggerCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface PigeonLoggerCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PigeonLoggerCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PigeonLoggerCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PigeonLoggerCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PigeonLoggerGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    PigeonLoggerCodecReaderWriter *readerWriter = [[PigeonLoggerCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void PigeonLoggerSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PigeonLogger> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.v"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(vMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(vMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api vMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.d"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(dMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(dMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api dMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.i"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(iMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(iMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api iMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.w"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(wMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(wMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api wMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PigeonLogger.e"
        binaryMessenger:binaryMessenger
        codec:PigeonLoggerGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(eMessage:error:)], @"PigeonLogger api (%@) doesn't respond to @selector(eMessage:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_message = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api eMessage:arg_message error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *TimelineSyncControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void TimelineSyncControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<TimelineSyncControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.TimelineSyncControl.syncTimelineToWatchLater"
        binaryMessenger:binaryMessenger
        codec:TimelineSyncControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(syncTimelineToWatchLaterWithError:)], @"TimelineSyncControl api (%@) doesn't respond to @selector(syncTimelineToWatchLaterWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api syncTimelineToWatchLaterWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface WorkaroundsControlCodecReader : FlutterStandardReader
@end
@implementation WorkaroundsControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [ListWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface WorkaroundsControlCodecWriter : FlutterStandardWriter
@end
@implementation WorkaroundsControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface WorkaroundsControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation WorkaroundsControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[WorkaroundsControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[WorkaroundsControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *WorkaroundsControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    WorkaroundsControlCodecReaderWriter *readerWriter = [[WorkaroundsControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void WorkaroundsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<WorkaroundsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.WorkaroundsControl.getNeededWorkarounds"
        binaryMessenger:binaryMessenger
        codec:WorkaroundsControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getNeededWorkaroundsWithError:)], @"WorkaroundsControl api (%@) doesn't respond to @selector(getNeededWorkaroundsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        ListWrapper *output = [api getNeededWorkaroundsWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface AppInstallControlCodecReader : FlutterStandardReader
@end
@implementation AppInstallControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [ListWrapper fromList:[self readValue]];
    case 129: 
      return [NumberWrapper fromList:[self readValue]];
    case 130: 
      return [PbwAppInfo fromList:[self readValue]];
    case 131: 
      return [StringWrapper fromList:[self readValue]];
    case 132: 
      return [WatchResource fromList:[self readValue]];
    case 133: 
      return [WatchappInfo fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface AppInstallControlCodecWriter : FlutterStandardWriter
@end
@implementation AppInstallControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[ListWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[NumberWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[PbwAppInfo class]]) {
    [self writeByte:130];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:131];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[WatchResource class]]) {
    [self writeByte:132];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[WatchappInfo class]]) {
    [self writeByte:133];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface AppInstallControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppInstallControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppInstallControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppInstallControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppInstallControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    AppInstallControlCodecReaderWriter *readerWriter = [[AppInstallControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void AppInstallControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<AppInstallControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.getAppInfo"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getAppInfoLocalPbwUri:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(getAppInfoLocalPbwUri:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_localPbwUri = GetNullableObjectAtIndex(args, 0);
        [api getAppInfoLocalPbwUri:arg_localPbwUri completion:^(PbwAppInfo *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.subscribeToAppStatus"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(subscribeToAppStatusWithError:)], @"AppInstallControl api (%@) doesn't respond to @selector(subscribeToAppStatusWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api subscribeToAppStatusWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.unsubscribeFromAppStatus"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(unsubscribeFromAppStatusWithError:)], @"AppInstallControl api (%@) doesn't respond to @selector(unsubscribeFromAppStatusWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api unsubscribeFromAppStatusWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppInstallControl.sendAppOrderToWatch"
        binaryMessenger:binaryMessenger
        codec:AppInstallControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(sendAppOrderToWatchUuidStringList:completion:)], @"AppInstallControl api (%@) doesn't respond to @selector(sendAppOrderToWatchUuidStringList:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        ListWrapper *arg_uuidStringList = GetNullableObjectAtIndex(args, 0);
        [api sendAppOrderToWatchUuidStringList:arg_uuidStringList completion:^(NumberWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface AppLifecycleControlCodecReader : FlutterStandardReader
@end
@implementation AppLifecycleControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [BooleanWrapper fromList:[self readValue]];
    case 129: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface AppLifecycleControlCodecWriter : FlutterStandardWriter
@end
@implementation AppLifecycleControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface AppLifecycleControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation AppLifecycleControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[AppLifecycleControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[AppLifecycleControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *AppLifecycleControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    AppLifecycleControlCodecReaderWriter *readerWriter = [[AppLifecycleControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void AppLifecycleControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<AppLifecycleControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppLifecycleControl.openAppOnTheWatch"
        binaryMessenger:binaryMessenger
        codec:AppLifecycleControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openAppOnTheWatchUuidString:completion:)], @"AppLifecycleControl api (%@) doesn't respond to @selector(openAppOnTheWatchUuidString:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_uuidString = GetNullableObjectAtIndex(args, 0);
        [api openAppOnTheWatchUuidString:arg_uuidString completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface PackageDetailsCodecReader : FlutterStandardReader
@end
@implementation PackageDetailsCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [AppEntriesPigeon fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface PackageDetailsCodecWriter : FlutterStandardWriter
@end
@implementation PackageDetailsCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[AppEntriesPigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface PackageDetailsCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation PackageDetailsCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[PackageDetailsCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[PackageDetailsCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *PackageDetailsGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    PackageDetailsCodecReaderWriter *readerWriter = [[PackageDetailsCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void PackageDetailsSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<PackageDetails> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.PackageDetails.getPackageList"
        binaryMessenger:binaryMessenger
        codec:PackageDetailsGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(getPackageListWithError:)], @"PackageDetails api (%@) doesn't respond to @selector(getPackageListWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        AppEntriesPigeon *output = [api getPackageListWithError:&error];
        callback(wrapResult(output, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface ScreenshotsControlCodecReader : FlutterStandardReader
@end
@implementation ScreenshotsControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [ScreenshotResult fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface ScreenshotsControlCodecWriter : FlutterStandardWriter
@end
@implementation ScreenshotsControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[ScreenshotResult class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface ScreenshotsControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation ScreenshotsControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[ScreenshotsControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[ScreenshotsControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *ScreenshotsControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    ScreenshotsControlCodecReaderWriter *readerWriter = [[ScreenshotsControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void ScreenshotsControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<ScreenshotsControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.ScreenshotsControl.takeWatchScreenshot"
        binaryMessenger:binaryMessenger
        codec:ScreenshotsControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(takeWatchScreenshotWithCompletion:)], @"ScreenshotsControl api (%@) doesn't respond to @selector(takeWatchScreenshotWithCompletion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        [api takeWatchScreenshotWithCompletion:^(ScreenshotResult *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
NSObject<FlutterMessageCodec> *AppLogControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  sSharedObject = [FlutterStandardMessageCodec sharedInstance];
  return sSharedObject;
}

void AppLogControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<AppLogControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppLogControl.startSendingLogs"
        binaryMessenger:binaryMessenger
        codec:AppLogControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(startSendingLogsWithError:)], @"AppLogControl api (%@) doesn't respond to @selector(startSendingLogsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api startSendingLogsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.AppLogControl.stopSendingLogs"
        binaryMessenger:binaryMessenger
        codec:AppLogControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(stopSendingLogsWithError:)], @"AppLogControl api (%@) doesn't respond to @selector(stopSendingLogsWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api stopSendingLogsWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface FirmwareUpdateControlCodecReader : FlutterStandardReader
@end
@implementation FirmwareUpdateControlCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [BooleanWrapper fromList:[self readValue]];
    case 129: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface FirmwareUpdateControlCodecWriter : FlutterStandardWriter
@end
@implementation FirmwareUpdateControlCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[BooleanWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface FirmwareUpdateControlCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation FirmwareUpdateControlCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[FirmwareUpdateControlCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[FirmwareUpdateControlCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *FirmwareUpdateControlGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    FirmwareUpdateControlCodecReaderWriter *readerWriter = [[FirmwareUpdateControlCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void FirmwareUpdateControlSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<FirmwareUpdateControl> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FirmwareUpdateControl.checkFirmwareCompatible"
        binaryMessenger:binaryMessenger
        codec:FirmwareUpdateControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(checkFirmwareCompatibleFwUri:completion:)], @"FirmwareUpdateControl api (%@) doesn't respond to @selector(checkFirmwareCompatibleFwUri:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_fwUri = GetNullableObjectAtIndex(args, 0);
        [api checkFirmwareCompatibleFwUri:arg_fwUri completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.FirmwareUpdateControl.beginFirmwareUpdate"
        binaryMessenger:binaryMessenger
        codec:FirmwareUpdateControlGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(beginFirmwareUpdateFwUri:completion:)], @"FirmwareUpdateControl api (%@) doesn't respond to @selector(beginFirmwareUpdateFwUri:completion:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_fwUri = GetNullableObjectAtIndex(args, 0);
        [api beginFirmwareUpdateFwUri:arg_fwUri completion:^(BooleanWrapper *_Nullable output, FlutterError *_Nullable error) {
          callback(wrapResult(output, error));
        }];
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface KeepUnusedHackCodecReader : FlutterStandardReader
@end
@implementation KeepUnusedHackCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [PebbleScanDevicePigeon fromList:[self readValue]];
    case 129: 
      return [WatchResource fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface KeepUnusedHackCodecWriter : FlutterStandardWriter
@end
@implementation KeepUnusedHackCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[PebbleScanDevicePigeon class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else if ([value isKindOfClass:[WatchResource class]]) {
    [self writeByte:129];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface KeepUnusedHackCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation KeepUnusedHackCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[KeepUnusedHackCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[KeepUnusedHackCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *KeepUnusedHackGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    KeepUnusedHackCodecReaderWriter *readerWriter = [[KeepUnusedHackCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void KeepUnusedHackSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<KeepUnusedHack> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.KeepUnusedHack.keepPebbleScanDevicePigeon"
        binaryMessenger:binaryMessenger
        codec:KeepUnusedHackGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(keepPebbleScanDevicePigeonCls:error:)], @"KeepUnusedHack api (%@) doesn't respond to @selector(keepPebbleScanDevicePigeonCls:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        PebbleScanDevicePigeon *arg_cls = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api keepPebbleScanDevicePigeonCls:arg_cls error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.KeepUnusedHack.keepWatchResource"
        binaryMessenger:binaryMessenger
        codec:KeepUnusedHackGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(keepWatchResourceCls:error:)], @"KeepUnusedHack api (%@) doesn't respond to @selector(keepWatchResourceCls:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        WatchResource *arg_cls = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api keepWatchResourceCls:arg_cls error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
@interface KMPApiCodecReader : FlutterStandardReader
@end
@implementation KMPApiCodecReader
- (nullable id)readValueOfType:(UInt8)type {
  switch (type) {
    case 128: 
      return [StringWrapper fromList:[self readValue]];
    default:
      return [super readValueOfType:type];
  }
}
@end

@interface KMPApiCodecWriter : FlutterStandardWriter
@end
@implementation KMPApiCodecWriter
- (void)writeValue:(id)value {
  if ([value isKindOfClass:[StringWrapper class]]) {
    [self writeByte:128];
    [self writeValue:[value toList]];
  } else {
    [super writeValue:value];
  }
}
@end

@interface KMPApiCodecReaderWriter : FlutterStandardReaderWriter
@end
@implementation KMPApiCodecReaderWriter
- (FlutterStandardWriter *)writerWithData:(NSMutableData *)data {
  return [[KMPApiCodecWriter alloc] initWithData:data];
}
- (FlutterStandardReader *)readerWithData:(NSData *)data {
  return [[KMPApiCodecReader alloc] initWithData:data];
}
@end

NSObject<FlutterMessageCodec> *KMPApiGetCodec(void) {
  static FlutterStandardMessageCodec *sSharedObject = nil;
  static dispatch_once_t sPred = 0;
  dispatch_once(&sPred, ^{
    KMPApiCodecReaderWriter *readerWriter = [[KMPApiCodecReaderWriter alloc] init];
    sSharedObject = [FlutterStandardMessageCodec codecWithReaderWriter:readerWriter];
  });
  return sSharedObject;
}

void KMPApiSetup(id<FlutterBinaryMessenger> binaryMessenger, NSObject<KMPApi> *api) {
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.KMPApi.updateToken"
        binaryMessenger:binaryMessenger
        codec:KMPApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(updateTokenToken:error:)], @"KMPApi api (%@) doesn't respond to @selector(updateTokenToken:error:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        NSArray *args = message;
        StringWrapper *arg_token = GetNullableObjectAtIndex(args, 0);
        FlutterError *error;
        [api updateTokenToken:arg_token error:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.KMPApi.openLockerView"
        binaryMessenger:binaryMessenger
        codec:KMPApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openLockerViewWithError:)], @"KMPApi api (%@) doesn't respond to @selector(openLockerViewWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api openLockerViewWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
  {
    FlutterBasicMessageChannel *channel =
      [[FlutterBasicMessageChannel alloc]
        initWithName:@"dev.flutter.pigeon.KMPApi.openStoreView"
        binaryMessenger:binaryMessenger
        codec:KMPApiGetCodec()];
    if (api) {
      NSCAssert([api respondsToSelector:@selector(openStoreViewWithError:)], @"KMPApi api (%@) doesn't respond to @selector(openStoreViewWithError:)", api);
      [channel setMessageHandler:^(id _Nullable message, FlutterReply callback) {
        FlutterError *error;
        [api openStoreViewWithError:&error];
        callback(wrapResult(nil, error));
      }];
    } else {
      [channel setMessageHandler:nil];
    }
  }
}
